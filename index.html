<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>K9-Delta</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0a0a; color: #fff; font-family: 'Courier New', monospace; overflow: hidden; }
  canvas { display: block; }
  #ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
  #hud { position: fixed; top: 10px; left: 10px; font-size: 13px; color: #0f0; text-shadow: 0 0 6px #0f0; }
  #hud-right { position: fixed; top: 10px; right: 10px; text-align: right; font-size: 13px; color: #0f0; text-shadow: 0 0 6px #0f0; }
  #wave-banner { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); font-size: 36px; color: #ff0; text-shadow: 0 0 20px #ff0; display: none; pointer-events: none; }
  #shop-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.88); display: none; pointer-events: all; z-index: 100; overflow-y: auto; touch-action: pan-y; }
  #shop-box { margin: 0 auto; width: min(720px, 100%); min-height: 100%; background: #0d0d1a; border-left: 2px solid #0af; border-right: 2px solid #0af; padding: 20px 16px 40px; box-sizing: border-box; }
  #shop-box h2 { color: #0af; text-align: center; margin-bottom: 6px; font-size: 22px; letter-spacing: 3px; }
  #shop-coins { text-align: center; color: #ff0; margin-bottom: 18px; font-size: 16px; }
  .shop-section { margin-bottom: 16px; }
  .shop-section h3 { color: #0f0; border-bottom: 1px solid #0f04; margin-bottom: 10px; padding-bottom: 4px; font-size: 13px; letter-spacing: 2px; }
  .shop-items { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 10px; }
  .shop-item { background: #111; border: 1px solid #333; border-radius: 6px; padding: 10px; cursor: pointer; transition: border-color 0.2s; pointer-events: all; }
  .shop-item:hover { border-color: #0af; }
  .shop-item.owned { border-color: #0f0; opacity: 0.7; cursor: default; }
  .shop-item.cant-afford { opacity: 0.4; cursor: default; }
  .shop-item h4 { font-size: 12px; color: #fff; margin-bottom: 4px; }
  .shop-item p { font-size: 11px; color: #888; margin-bottom: 6px; }
  .shop-item .price { font-size: 12px; color: #ff0; }
  .shop-item .level-bar { height: 4px; background: #333; border-radius: 2px; margin-top: 6px; }
  .shop-item .level-fill { height: 100%; background: #0af; border-radius: 2px; transition: width 0.3s; }
  #close-shop { display: block; margin: 18px auto 0; padding: 14px 40px; background: #0af; color: #000; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-size: 14px; font-weight: bold; letter-spacing: 2px; width: 100%; box-sizing: border-box; }
  #close-shop:hover { background: #0df; }
  .wpn-stats { display: flex; gap: 10px; margin-top: 5px; flex-wrap: wrap; }
  .wpn-stat { font-size: 10px; color: #888; }
  .wpn-stat-label { color: #555; }
  /* Weapon row: unlock + expand */
  .wpn-row { display: flex; gap: 8px; align-items: stretch; margin-bottom: 8px; }
  .wpn-unlock { flex: 1; background: #111; border: 1px solid #333; border-radius: 6px; padding: 10px 12px; cursor: pointer; pointer-events: all; transition: border-color 0.2s; display: flex; align-items: center; gap: 10px; }
  .wpn-unlock:hover { border-color: #0af; }
  .wpn-unlock.owned { border-color: #0f0; }
  .wpn-unlock.cant-afford { opacity: 0.4; cursor: default; }
  .wpn-unlock .wpn-name { font-size: 13px; color: #fff; flex: 1; }
  .wpn-unlock .wpn-price { font-size: 12px; color: #ff0; white-space: nowrap; }
  .wpn-unlock .wpn-owned-label { font-size: 11px; color: #0f0; }
  .wpn-expand-btn { background: #111; border: 1px solid #333; border-radius: 6px; padding: 10px 14px; cursor: pointer; pointer-events: all; color: #0af; font-size: 18px; transition: border-color 0.2s, background 0.2s; }
  .wpn-expand-btn:hover { border-color: #0af; background: #0af2; }
  .wpn-expand-btn.open { border-color: #0af; background: #0af2; }
  .wpn-upgrades { display: flex; gap: 8px; margin-bottom: 8px; padding: 8px; background: #0a0a14; border: 1px solid #0af4; border-radius: 6px; }
  .wpn-upg-btn { flex: 1; background: #111; border: 1px solid #333; border-radius: 6px; padding: 10px; cursor: pointer; pointer-events: all; transition: border-color 0.2s; text-align: center; }
  .wpn-upg-btn:hover { border-color: #0af; }
  .wpn-upg-btn.cant-afford { opacity: 0.4; cursor: default; }
  .wpn-upg-btn .upg-icon { font-size: 18px; }
  .wpn-upg-btn .upg-name { font-size: 12px; color: #fff; margin: 4px 0 2px; }
  .wpn-upg-btn .upg-desc { font-size: 10px; color: #888; margin-bottom: 6px; }
  .wpn-upg-btn .upg-price { font-size: 12px; color: #ff0; }
  #game-over { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; z-index: 200; justify-content: center; align-items: center; flex-direction: column; color: #fff; text-align: center; }
  #restart-btn { margin-top: 24px; padding: 12px 40px; background: #f00; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-size: 16px; letter-spacing: 2px; }
  #restart-btn:hover { background: #f44; }
  #controls-hint { position: fixed; bottom: 10px; left: 10px; font-size: 11px; color: #444; }
  @media (hover: none) { #controls-hint { display: none; } }
  #weapon-bar { position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; }
  .weapon-slot { width: 54px; height: 54px; background: #111; border: 2px solid #333; border-radius: 6px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 10px; color: #888; cursor: pointer; pointer-events: all; transition: border-color 0.2s; }
  .weapon-slot.active { border-color: #ff0; color: #ff0; }
  .weapon-slot .wname { font-size: 9px; margin-top: 2px; }
  #shop-btn { position: fixed; bottom: 10px; right: 10px; padding: 8px 20px; background: #0af3; border: 1px solid #0af; color: #0af; border-radius: 4px; cursor: pointer; font-family: inherit; font-size: 12px; letter-spacing: 1px; pointer-events: all; }
  #shop-btn:hover { background: #0af5; }
  .companion-status { position: fixed; bottom: 110px; left: 10px; font-size: 11px; color: #0f0; text-shadow: 0 0 4px #0f0; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div id="hud">
    <div id="hud-hp">HP: <span id="hp-val">100</span></div>
    <div id="hud-coins">COINS: <span id="coins-val">0</span></div>
    <div id="hud-score">SCORE: <span id="score-val">0</span></div>
    <div id="hud-kills">KILLS: <span id="kills-val">0</span></div>
  </div>
  <div id="hud-right">
    <div>WAVE: <span id="wave-val">0</span></div>
    <div id="wave-status"></div>
  </div>
  <div id="wave-banner"></div>
  <div id="weapon-bar"></div>
  <div class="companion-status" id="companion-status"></div>
  <button id="shop-btn" onclick="openShop()">SHOP [E]</button>
  <div id="controls-hint">WASD: beveg | 1-5: bytt v&aring;pen | E: shop</div>
</div>

<div id="shop-overlay">
  <div id="shop-box">
    <h2>SUPPLY DROP</h2>
    <div id="shop-coins">COINS: <span id="shop-coins-val">0</span></div>
    <div id="shop-content"></div>
    <button id="close-shop" onclick="closeShop()">BACK TO BATTLE [E]</button>
  </div>
</div>

<div id="game-over">
  <h1>MISSION FAILED</h1>
  <p>Wave: <span id="go-wave">0</span></p>
  <p>Score: <span id="go-score">0</span></p>
  <p>Kills: <span id="go-kills">0</span></p>
  <button id="restart-btn" onclick="initGame()">RETRY</button>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

// ========== CONSTANTS ==========
const TILE = 48;
const COLORS = {
  ground: '#1a1a12',
  groundLight: '#1e1e16',
  player: '#4af',
  bullet: '#ff0',
  enemySoldier: '#c44',
  enemyHeavy: '#c84',
  enemyVehicle: '#996633',
  enemyDrone: '#ff4400',
  enemyHeli: '#884400',
  dog: '#c8822a',
  drone: '#4af',
  xp: '#ff0',
};

// ========== ISLAND DEFINITIONS ==========
const ISLAND_DEFS = [
  { rx: 0.36, ry: 0.38, tilt: 0,    beach: 55, grass: '#3a6b2a', grassDark: '#2d5520', sand: '#c8a86e', name: 'Alpha Island' },
  { rx: 0.28, ry: 0.44, tilt: 0.3,  beach: 45, grass: '#2d6b3a', grassDark: '#1e5028', sand: '#b8986e', name: 'Bravo Atoll' },
  { rx: 0.42, ry: 0.30, tilt: -0.2, beach: 65, grass: '#4a7a2a', grassDark: '#376020', sand: '#d4b878', name: 'Charlie Key' },
  { rx: 0.32, ry: 0.32, tilt: 0.5,  beach: 50, grass: '#3a5a1e', grassDark: '#284414', sand: '#c0a060', name: 'Delta Cay' },
  { rx: 0.38, ry: 0.42, tilt: -0.4, beach: 70, grass: '#507a30', grassDark: '#3c6020', sand: '#ccaa70', name: 'Echo Reef' },
  { rx: 0.25, ry: 0.35, tilt: 0.8,  beach: 40, grass: '#286030', grassDark: '#1a4820', sand: '#b49060', name: 'Foxtrot Shoal' },
  { rx: 0.44, ry: 0.34, tilt: 0.1,  beach: 60, grass: '#406830', grassDark: '#2e5020', sand: '#d0ac6c', name: 'Golf Sandbar' },
];


// Base stats â€” per-weapon upgrade multipliers applied in getCurrentWeapon()
const WEAPON_DEFS = [
  { id: 'pistol',   name: 'Pistol',      icon: 'ðŸ”«', damage: 18,  rate: 400,  speed: 420, range: 320, spread: 0,    bullets: 1, explosive: false, flame: false },
  { id: 'rifle',    name: 'Rifle',       icon: 'ðŸª–', damage: 28,  rate: 180,  speed: 560, range: 480, spread: 0.05, bullets: 1, explosive: false, flame: false },
  { id: 'shotgun',  name: 'Shotgun',     icon: 'ðŸ’¥', damage: 22,  rate: 700,  speed: 380, range: 260, spread: 0.25, bullets: 5, explosive: false, flame: false },
  { id: 'smg',      name: 'SMG',         icon: 'âš¡', damage: 14,  rate: 90,   speed: 500, range: 360, spread: 0.08, bullets: 1, explosive: false, flame: false },
  { id: 'sniper',   name: 'Sniper',      icon: 'ðŸŽ¯', damage: 90,  rate: 1200, speed: 800, range: 700, spread: 0,    bullets: 1, explosive: false, flame: false },
  { id: 'flamer',   name: 'Flammekaster',icon: 'ðŸ”¥', damage: 8,   rate: 60,   speed: 220, range: 180, spread: 0.35, bullets: 3, explosive: false, flame: true  },
];

// ========== UPGRADE CATALOGUE ==========
// Per-weapon upgrades: each level gives less bonus than the previous.
// Damage: +20% * (0.80^(lvl-1)) per level  â†’ strongly diminishing
// Rate:   +15% * (0.80^(lvl-1)) per level  â†’ strongly diminishing
// baseCost per weapon scales with the weapon's power tier.
// Global "all weapons at once" upgrades are intentionally removed.

function wpnDmgBonus(lvl) {
  // cumulative damage multiplier after 'lvl' purchases
  let mult = 1;
  for (let i = 0; i < lvl; i++) mult *= (1 + 0.20 * Math.pow(0.80, i));
  return mult;
}
function wpnRateBonus(lvl) {
  // cumulative rate multiplier (lower = faster) after 'lvl' purchases
  let mult = 1;
  for (let i = 0; i < lvl; i++) mult *= (1 - 0.15 * Math.pow(0.80, i));
  return mult;
}
function wpnDmgDesc(lvl) {
  const next = (0.20 * Math.pow(0.80, lvl) * 100).toFixed(1);
  const total = Math.round((wpnDmgBonus(lvl) - 1) * 100);
  return 'Skade +' + next + '% neste kjÃ¸p (totalt +' + total + '%)';
}
function wpnRateDesc(lvl) {
  const next = (0.15 * Math.pow(0.80, lvl) * 100).toFixed(1);
  const total = Math.round((1 - wpnRateBonus(lvl)) * 100);
  return 'Ildrate +' + next + '% neste kjÃ¸p (totalt +' + total + '%)';
}

// Helper: build per-weapon upgrade entries
function makeWpnUpgrades(id, name, icon, unlockId, dmgBase, rateBase) {
  return [
    { id: unlockId + '_dmg', section: name, name: 'Skade', icon: 'ðŸ”¥', wpnUpgrade: true,
      maxLevel: Infinity, baseCost: dmgBase, costScale: 1.35, requires: unlockId,
      desc: (lvl) => wpnDmgDesc(lvl),
      onBuy: (g, lvl) => { if (!g.wpnMults) g.wpnMults = {}; if (!g.wpnMults[id]) g.wpnMults[id] = {dmg:1,rate:1}; g.wpnMults[id].dmg = wpnDmgBonus(lvl); } },
    { id: unlockId + '_rate', section: name, name: 'Ildrate', icon: 'âš¡', wpnUpgrade: true,
      maxLevel: Infinity, baseCost: rateBase, costScale: 1.35, requires: unlockId,
      desc: (lvl) => wpnRateDesc(lvl),
      onBuy: (g, lvl) => { if (!g.wpnMults) g.wpnMults = {}; if (!g.wpnMults[id]) g.wpnMults[id] = {dmg:1,rate:1}; g.wpnMults[id].rate = wpnRateBonus(lvl); } },
  ];
}

const UPGRADES = [
  // --- Unlock weapons ---
  { id: 'buy_rifle',    section: 'Assault Rifle', name: 'LÃ¥s opp Rifle',        icon: 'ðŸª–',
    maxLevel: 1, baseCost: 80,
    desc: () => 'LÃ¥s opp Assault Rifle â€” hÃ¸y presisjon, halvautomatisk',
    onBuy: (g) => { g.unlockedWeapons.add('rifle'); } },
  { id: 'buy_shotgun',  section: 'Shotgun',       name: 'LÃ¥s opp Shotgun',      icon: 'ðŸ’¥',
    maxLevel: 1, baseCost: 100,
    desc: () => 'LÃ¥s opp Shotgun â€” 5 haglkorn, kraftig pÃ¥ kort hold',
    onBuy: (g) => { g.unlockedWeapons.add('shotgun'); } },
  { id: 'buy_smg',      section: 'SMG',           name: 'LÃ¥s opp SMG',          icon: 'âš¡',
    maxLevel: 1, baseCost: 120,
    desc: () => 'LÃ¥s opp SMG â€” ekstremt hÃ¸y ildrate',
    onBuy: (g) => { g.unlockedWeapons.add('smg'); } },
  { id: 'buy_sniper',   section: 'Sniper',        name: 'LÃ¥s opp Sniper',       icon: 'ðŸŽ¯',
    maxLevel: 1, baseCost: 180,
    desc: () => 'LÃ¥s opp Sniper Rifle â€” massiv enkeltskudds-skade',
    onBuy: (g) => { g.unlockedWeapons.add('sniper'); } },
  { id: 'buy_flamer',   section: 'Flammekaster',  name: 'LÃ¥s opp Flammekaster', icon: 'ðŸ”¥',
    maxLevel: 1, baseCost: 220,
    desc: () => 'LÃ¥s opp Flammekaster â€” brenner fiender over tid, korte hold',
    onBuy: (g) => { g.unlockedWeapons.add('flamer'); } },

  // --- Per-weapon upgrades (strongly diminishing returns) ---
  // Pistol always unlocked â€” use id 'pistol' as requires placeholder (always met)
  ...makeWpnUpgrades('pistol',   'Pistol',      'ðŸ”«', 'pistol_wpn',   45, 40),
  ...makeWpnUpgrades('rifle',    'Assault Rifle','ðŸª–', 'buy_rifle',    65, 60),
  ...makeWpnUpgrades('shotgun',  'Shotgun',      'ðŸ’¥', 'buy_shotgun',  70, 65),
  ...makeWpnUpgrades('smg',      'SMG',          'âš¡', 'buy_smg',      75, 70),
  ...makeWpnUpgrades('sniper',   'Sniper',       'ðŸŽ¯', 'buy_sniper',   90, 80),
  ...makeWpnUpgrades('flamer',   'Flammekaster', 'ðŸ”¥', 'buy_flamer',   80, 75),

  // --- Armor (infinite) ---
  { id: 'armor',  section: 'Rustning', name: 'Pansring',    icon: 'ðŸ›¡ï¸',
    maxLevel: Infinity, baseCost: 60, costScale: 1.35,
    desc: (lvl) => '+25 maks HP (Total bonus: +' + (lvl*25) + ')',
    onBuy: (g) => { g.player.maxHp += 25; g.player.hp += 25; } },
  { id: 'regen',  section: 'Rustning', name: 'Regenerasjon', icon: 'ðŸ’‰',
    maxLevel: Infinity, baseCost: 80, costScale: 1.45,
    desc: (lvl) => '+0.8 HP/s (Total: ' + (lvl*0.8).toFixed(1) + ' HP/s)',
    onBuy: (g) => { g.player.regen += 0.8; } },
  { id: 'speed',  section: 'Rustning', name: 'Hastighet',   icon: 'ðŸ‘Ÿ',
    maxLevel: Infinity, baseCost: 90, costScale: 1.5,
    desc: (lvl) => '+10% fart (Total: +' + Math.round((Math.pow(1.1,lvl)-1)*100) + '%)',
    onBuy: (g) => { g.player.speed *= 1.10; } },

  // --- Dog ---
  { id: 'dog',      section: 'Hunder', name: 'Rekrutter Rex',      icon: 'ðŸ•',
    maxLevel: 1, baseCost: 150,
    desc: () => 'Rex jakter og biter fiender',
    onBuy: (g) => { g.dog = createDog(g, -30); } },
  { id: 'dog2',     section: 'Hunder', name: 'Rekrutter Buddy',     icon: 'ðŸ¶',
    maxLevel: 1, baseCost: 200, requires: 'dog',
    desc: () => 'Buddy jakter ved siden av Rex',
    onBuy: (g) => { g.dog2 = createDog(g, 30); if(g.dog){ g.dog2.damage=g.dog.damage; g.dog2.speed=g.dog.speed; g.dog2.attackRate=g.dog.attackRate; } } },
  { id: 'dog_dmg',  section: 'Hunder', name: 'Bittskade',           icon: 'ðŸ¦·',
    maxLevel: Infinity, baseCost: 80, costScale: 1.4, requires: 'dog',
    desc: (lvl) => '+30% bittskade (Total: +' + Math.round((Math.pow(1.3,lvl)-1)*100) + '%)',
    onBuy: (g) => { allDogs(g).forEach(d => { d.damage *= 1.3; }); } },
  { id: 'dog_spd',  section: 'Hunder', name: 'Hastighet',           icon: 'ðŸ¾',
    maxLevel: Infinity, baseCost: 70, costScale: 1.35, requires: 'dog',
    desc: () => '+20% hundehastighet',
    onBuy: (g) => { allDogs(g).forEach(d => { d.speed *= 1.20; }); } },
  { id: 'dog_rate', section: 'Hunder', name: 'Angrepsrate',         icon: 'ðŸ’¢',
    maxLevel: Infinity, baseCost: 75, costScale: 1.4, requires: 'dog',
    desc: () => '+20% raskere angrep',
    onBuy: (g) => { allDogs(g).forEach(d => { d.attackRate *= 0.80; }); } },

  // --- Drone ---
  { id: 'drone',      section: 'Drone', name: 'Rekrutter Drone',  icon: 'ðŸš',
    maxLevel: 1, baseCost: 200,
    desc: () => 'Drone sirkulerer og skyter automatisk',
    onBuy: (g) => { g.drone = createDrone(g, 0); g.drones = [g.drone]; } },
  { id: 'drone_dmg',  section: 'Drone', name: 'Drone: Skade',     icon: 'ðŸ’£',
    maxLevel: Infinity, baseCost: 90, costScale: 1.4, requires: 'drone',
    desc: (lvl) => '+35% droneskade (Total: +' + Math.round((Math.pow(1.35,lvl)-1)*100) + '%)',
    onBuy: (g) => { (g.drones||[g.drone].filter(Boolean)).forEach(d => { if(d) d.damage *= 1.35; }); } },
  { id: 'drone_rate', section: 'Drone', name: 'Drone: Ildrate',   icon: 'ðŸ”',
    maxLevel: Infinity, baseCost: 85, costScale: 1.4, requires: 'drone',
    desc: () => '+25% raskere droneskyting',
    onBuy: (g) => { (g.drones||[g.drone].filter(Boolean)).forEach(d => { if(d) d.fireRate *= 0.75; }); } },

  { id: 'drone_count',section: 'Drone', name: 'Drone: Ekstra',    icon: 'âž•',
    maxLevel: 3, baseCost: 250, costScale: 2.0, requires: 'drone',
    desc: (lvl) => 'Legg til drone nr. ' + (lvl+1) + ' (maks 4)',
    onBuy: (g) => { g.extraDrones = (g.extraDrones||0)+1; rebuildDrones(g); } },
];

function upgradeCost(upg, currentLevel) {
  const base = upg.baseCost || 60;
  const scale = upg.costScale || 1.0;
  return Math.round(base * Math.pow(scale, currentLevel));
}

// ========== STATE ==========
let G;
let keys = {};
let animFrame;
const joystick = { active: false, touchId: null, baseX: 0, baseY: 0, dx: 0, dy: 0 };

// ========== HELPERS ==========
function rnd(a, b) { return a + Math.random() * (b - a); }
function rndInt(a, b) { return Math.floor(rnd(a, b + 1)); }
function dist(a, b) { return Math.hypot(b.x - a.x, b.y - a.y); }
function angle(a, b) { return Math.atan2(b.y - a.y, b.x - a.x); }
function norm(v) { const l = Math.hypot(v.x, v.y) || 1; return { x: v.x / l, y: v.y / l }; }

function spawnParticles(state, x, y, color, n, speedMin, speedMax, lifeMin, lifeMax, sizeMin, sizeMax) {
  if (sizeMin === undefined) sizeMin = 2;
  if (sizeMax === undefined) sizeMax = 4;
  for (let i = 0; i < n; i++) {
    const a = Math.random() * Math.PI * 2;
    const s = rnd(speedMin, speedMax);
    state.particles.push({
      x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s,
      life: rnd(lifeMin, lifeMax), maxLife: 1,
      color, size: rnd(sizeMin, sizeMax)
    });
  }
}

// ========== INIT ==========
function initGame() {
  cancelAnimationFrame(animFrame);
  document.getElementById('game-over').style.display = 'none';
  document.getElementById('shop-overlay').style.display = 'none';

  G = {
    time: 0,
    score: 0,
    coins: 0,
    kills: 0,
    wave: 0,
    waveState: 'prep',
    waveTimer: 800,
    waveEnemiesLeft: 0,
    waveSpawnTimer: 0,
    waveSpawnQueue: [],
    shopOpen: false,
    gameOver: false,
    paused: false,
    player: createPlayer(),
    bullets: [],
    enemyBullets: [],
    enemies: [],
    particles: [],
    floatTexts: [],
    drops: [],
    dog: null,
    dog2: null,
    drone: null,
    drones: [],
    extraDrones: 0,
    unlockedWeapons: new Set(['pistol']),
    purchasedUpgrades: new Set(),
    upgradeLevels: {},
    camX: 0,
    camY: 0,
    mapW: 3200,
    mapH: 2400,
    boats: [],
    islandIdx: 0,
    islandTransition: 0, // ms remaining for fade-out/in
  };

  G.player.x = G.mapW / 2;
  G.player.y = G.mapH / 2;

  buildWeaponBar();
  startNextWave();
  lastTime = 0;
  loop();
}

function createPlayer() {
  return {
    x: 0, y: 0, r: 14,
    hp: 100, maxHp: 100,
    speed: 160,
    regen: 0,
    facing: 0,
    moveAngle: 0,    // direction of last movement
    aimLockTimer: 0, // ms remaining for aim-lock after firing
    fireTimer: 0,
    weapons: ['pistol'],
    weaponIdx: 0,
    invincibleTimer: 0,
    regenAccum: 0,
  };
}

function createDog(g, offsetY) {
  return {
    x: g.player.x - 30, y: g.player.y + (offsetY || 0),
    r: 10, hp: 120, maxHp: 120,
    speed: 220, damage: 25,
    attackCooldown: 0, attackRate: 800,
    target: null, state: 'follow',
    color: COLORS.dog,
    followOffsetX: -35,
    followOffsetY: offsetY || 0,
  };
}

function createDrone(g, orbitOffset, orbitRadius) {
  const r = orbitRadius || 55;
  // Inner orbits faster, outer orbits slower
  const orbitSpeed = 2.2 - (r - 55) * 0.008;
  return {
    x: g.player.x, y: g.player.y - 40,
    r: 9, hp: 80, maxHp: 80,
    orbitAngle: orbitOffset || 0, orbitRadius: r,
    orbitSpeed: Math.max(0.8, orbitSpeed),
    damage: 20, fireRate: 600,
    fireTimer: 0, color: COLORS.drone,
  };
}

function allDogs(g) {
  const arr = [];
  if (g.dog) arr.push(g.dog);
  if (g.dog2) arr.push(g.dog2);
  return arr;
}

function rebuildDrones(g) {
  const total = 1 + (g.extraDrones || 0);
  if (!g.drones) g.drones = g.drone ? [g.drone] : [];
  while (g.drones.length < total) {
    const idx = g.drones.length;
    const offset = (idx / total) * Math.PI * 2;
    const radius = 55 + idx * 25;
    const nd = createDrone(g, offset, radius);
    if (g.drones.length > 0) {
      nd.damage = g.drones[0].damage;
      nd.fireRate = g.drones[0].fireRate;
      nd.maxHp = g.drones[0].maxHp;
      nd.hp = g.drones[0].maxHp;
    }
    g.drones.push(nd);
  }
}

// ========== WAVES ==========
function startNextWave() {
  G.wave++;
  G.waveState = 'prep';
  G.waveTimer = 3000;
  document.getElementById('wave-val').textContent = G.wave;

  // Every 5 waves: switch island
  if (G.wave > 1 && (G.wave - 1) % 5 === 0) {
    G.islandIdx = (G.islandIdx + 1) % ISLAND_DEFS.length;
    G.islandTransition = 1200;
    G.player.x = G.mapW / 2;
    G.player.y = G.mapH / 2;
    G.enemies = [];
    G.bullets = [];
    G.enemyBullets = [];
    G.boats = [];
    const idef = ISLAND_DEFS[G.islandIdx];
    showWaveBanner('WAVE ' + G.wave + '  â€”  ' + idef.name);
  } else {
    showWaveBanner('WAVE ' + G.wave);
  }
}

function showWaveBanner(txt) {
  const el = document.getElementById('wave-banner');
  el.textContent = txt;
  el.style.display = 'block';
  setTimeout(() => { el.style.display = 'none'; }, 2000);
}

function buildWaveQueue() {
  const n = G.wave;
  const queue = [];
  const soldierCount = Math.floor(3 + n * 1.8 + n * n * 0.1);
  const heavyCount   = Math.floor(n * 0.5 + n * n * 0.04);
  const vehicleCount = Math.floor(n * 0.3 + n * n * 0.02);
  // Enemy drones appear from wave 4
  const eDroneCount  = n >= 4 ? Math.floor((n - 3) * 0.8 + (n - 3) * (n - 3) * 0.03) : 0;
  // Helicopters appear from wave 7
  const heliCount    = n >= 7 ? Math.floor((n - 6) * 0.5 + (n - 6) * (n - 6) * 0.02) : 0;

  for (let i = 0; i < soldierCount; i++) queue.push({ type: 'soldier', delay: i * 350 });
  for (let i = 0; i < heavyCount;   i++) queue.push({ type: 'heavy',   delay: 600 + i * 500 });
  for (let i = 0; i < vehicleCount; i++) queue.push({ type: 'vehicle', delay: 1000 + i * 800 });
  for (let i = 0; i < eDroneCount;  i++) queue.push({ type: 'edrone',  delay: 400 + i * 600 });
  for (let i = 0; i < heliCount;    i++) queue.push({ type: 'heli',    delay: 800 + i * 900 });

  queue.sort((a, b) => a.delay - b.delay);
  G.waveSpawnQueue = queue;
  G.waveEnemiesLeft = queue.length;
  G.waveSpawnTimer = 0;
}

function spawnEnemy(type) {
  const cx = G.mapW / 2, cy = G.mapH / 2;
  const idef = ISLAND_DEFS[G.islandIdx];
  const islandRx = G.mapW * idef.rx, islandRy = G.mapH * idef.ry;
  const hpScale  = Math.pow(1.07, G.wave - 1);
  const spdScale = 1 + (G.wave - 1) * 0.03;

  const isAerial = type === 'edrone' || type === 'heli';

  let x, y;
  if (isAerial) {
    // Fly in from screen edges
    const p = G.player;
    const side = rndInt(0, 3);
    const vw = canvas.width, vh = canvas.height;
    if (side === 0) { x = p.x + rnd(-vw * 0.7, vw * 0.7); y = p.y - vh * 0.6 - 80; }
    else if (side === 1) { x = p.x + rnd(-vw * 0.7, vw * 0.7); y = p.y + vh * 0.6 + 80; }
    else if (side === 2) { x = p.x - vw * 0.6 - 80; y = p.y + rnd(-vh * 0.7, vh * 0.7); }
    else { x = p.x + vw * 0.6 + 80; y = p.y + rnd(-vh * 0.7, vh * 0.7); }
    x = Math.max(20, Math.min(G.mapW - 20, x));
    y = Math.max(20, Math.min(G.mapH - 20, y));
  } else {
    // Land troops arrive by boat at shoreline
    const angle = rnd(0, Math.PI * 2);
    // Place boat just outside island edge
    const bx = cx + Math.cos(angle) * (islandRx + 80);
    const by = cy + Math.sin(angle) * (islandRy + 80);
    // Troop lands at island edge
    x = cx + Math.cos(angle) * (islandRx - 20);
    y = cy + Math.sin(angle) * (islandRy - 20);
    // Spawn a visual boat that fades out
    G.boats.push({ x: bx, y: by, angle: angle + Math.PI / 2, life: 3000 });
  }

  if (type === 'soldier') {
    G.enemies.push({ type:'soldier', x, y, r:11, hp: 40*hpScale, maxHp:40*hpScale, speed:(70+G.wave*1.5)*spdScale, damage:10+G.wave*0.4, fireRate:1400, fireTimer:rnd(0,1400), range:280, color:COLORS.enemySoldier, score:10, coins:rndInt(3,7) });
  } else if (type === 'heavy') {
    G.enemies.push({ type:'heavy', x, y, r:16, hp: 140*hpScale, maxHp:140*hpScale, speed:(45+G.wave*1.2)*spdScale, damage:18+G.wave*0.6, fireRate:900, fireTimer:rnd(0,900), range:240, color:COLORS.enemyHeavy, score:30, coins:rndInt(11,19) });
  } else if (type === 'vehicle') {
    G.enemies.push({ type:'vehicle', x, y, r:22, hp: 300*hpScale, maxHp:300*hpScale, speed:(80+G.wave*2)*spdScale, damage:25+G.wave*1.0, fireRate:1800, fireTimer:rnd(0,1800), range:350, color:COLORS.enemyVehicle, score:80, coins:rndInt(30,49) });
  } else if (type === 'edrone') {
    G.enemies.push({ type:'edrone', x, y, r:10, hp: 25*hpScale, maxHp:25*hpScale, speed:(140+G.wave*3)*spdScale, damage:0, fireRate:99999, fireTimer:0, range:0, color:COLORS.enemyDrone, score:25, coins:rndInt(6,12), explodeDmg:35+G.wave*1.5, spinAngle:0 });
  } else if (type === 'heli') {
    G.enemies.push({ type:'heli', x, y, r:20, hp: 220*hpScale, maxHp:220*hpScale, speed:(60+G.wave*1.5)*spdScale, damage:0, fireRate:2200, fireTimer:rnd(0,2200), range:400, color:COLORS.enemyHeli, score:60, coins:rndInt(21,34), rocketDmg:28+G.wave*1.2, rotorAngle:0 });
  }
}

// ========== MAIN LOOP ==========
let lastTime = 0;
function loop(ts) {
  if (ts === undefined) ts = 0;
  if (G.gameOver) return;
  const dt = Math.max(0, Math.min((ts - lastTime) / 1000, 0.05));
  lastTime = ts;
  if (!G.shopOpen && !G.paused) {
    update(dt * 1000);
  }
  render();
  animFrame = requestAnimationFrame(loop);
}

// ========== UPDATE ==========
function update(dt) {
  G.time += dt;
  const dtSec = dt / 1000;
  const p = G.player;

  if (G.islandTransition > 0) G.islandTransition = Math.max(0, G.islandTransition - dt);

  G.camX = p.x - canvas.width / 2;
  G.camY = p.y - canvas.height / 2;

  let dx = joystick.dx;
  let dy = joystick.dy;
  if (keys['w'] || keys['arrowup'])    dy -= 1;
  if (keys['s'] || keys['arrowdown'])  dy += 1;
  if (keys['a'] || keys['arrowleft'])  dx -= 1;
  if (keys['d'] || keys['arrowright']) dx += 1;
  const dlen = Math.hypot(dx, dy);
  if (dlen > 1) { dx /= dlen; dy /= dlen; }
  const nx = p.x + dx * p.speed * dtSec;
  const ny = p.y + dy * p.speed * dtSec;
  // Constrain player to island ellipse
  const icx = G.mapW / 2, icy = G.mapH / 2;
  const _idef = ISLAND_DEFS[G.islandIdx];
  const irx = G.mapW * _idef.rx - p.r, iry = G.mapH * _idef.ry - p.r;
  const normX = (nx - icx) / irx, normY = (ny - icy) / iry;
  if (normX * normX + normY * normY <= 1) {
    p.x = nx; p.y = ny;
  } else {
    // Slide along ellipse edge
    const onlyX = (p.x + dx * p.speed * dtSec - icx) / irx;
    const onlyY = (p.y - icy) / iry;
    if (onlyX * onlyX + onlyY * onlyY <= 1) p.x = p.x + dx * p.speed * dtSec;
    const onlyX2 = (p.x - icx) / irx;
    const onlyY2 = (p.y + dy * p.speed * dtSec - icy) / iry;
    if (onlyX2 * onlyX2 + onlyY2 * onlyY2 <= 1) p.y = p.y + dy * p.speed * dtSec;
  }

  // Track movement direction
  if (dx !== 0 || dy !== 0) p.moveAngle = Math.atan2(dy, dx);

  // Aim-lock timer counts down after firing; while active, facing = aim direction
  if (p.aimLockTimer > 0) {
    p.aimLockTimer -= dt;
  } else {
    // No aim lock: face movement direction if moving, otherwise keep last facing
    if (dx !== 0 || dy !== 0) p.facing = p.moveAngle;
  }

  if (p.regen > 0) {
    p.regenAccum += p.regen * dtSec;
    if (p.regenAccum >= 1) { p.hp = Math.min(p.maxHp, p.hp + Math.floor(p.regenAccum)); p.regenAccum %= 1; }
  }

  if (p.invincibleTimer > 0) p.invincibleTimer -= dt;

  if (G.waveState === 'prep') {
    G.waveTimer -= dt;
    if (G.waveTimer <= 0) {
      G.waveState = 'active';
      buildWaveQueue();
    }
  } else if (G.waveState === 'active') {
    G.waveSpawnTimer += dt;
    while (G.waveSpawnQueue.length > 0 && G.waveSpawnTimer >= G.waveSpawnQueue[0].delay) {
      spawnEnemy(G.waveSpawnQueue.shift().type);
    }
    if (G.waveSpawnQueue.length === 0 && G.enemies.length === 0) {
      G.waveState = 'complete';
      G.waveTimer = 3000;
      document.getElementById('wave-status').textContent = 'WAVE CLEAR!';
    }
  } else if (G.waveState === 'complete') {
    G.waveTimer -= dt;
    if (G.waveTimer <= 0) {
      document.getElementById('wave-status').textContent = '';
      startNextWave();
    }
  }

  const wdef = getCurrentWeapon();
  p.fireTimer -= dt;
  if (p.fireTimer <= 0 && G.enemies.length > 0) {
    const target = nearestEnemy(p);
    if (target && dist(p, target) <= wdef.range) {
      fireWeapon(p, target, wdef);
      p.fireTimer = wdef.rate;
      const aimDir = angle(p, target);
      p.facing = aimDir;
      p.aimLockTimer = 1000; // 1 second sticky aim
    }
  }

  G.bullets = G.bullets.filter(b => {
    b.x += b.vx * dtSec;
    b.y += b.vy * dtSec;
    b.life -= dt;
    if (b.life <= 0) {
      if (b.explosive) explodeAt(b.x, b.y, b.damage, 80, '#f80');
      return false;
    }
    for (let i = G.enemies.length - 1; i >= 0; i--) {
      const e = G.enemies[i];
      if (dist(b, e) < e.r + b.r) {
        if (b.explosive) {
          explodeAt(b.x, b.y, b.damage, 80, '#f80');
          return false;
        }
        if (b.flame) {
          // Flame ticks damage on contact, short range, pierce all
          hitEnemy(e, b.damage);
          spawnParticles(G, b.x, b.y, '#f60', 3, 20, 60, 80, 200, 3, 6);
          return false;
        }
        hitEnemy(e, b.damage);
        spawnParticles(G, b.x, b.y, '#f80', 5, 30, 100, 150, 350);
        return b.pierce ? true : false;
      }
    }
    return true;
  });

  G.enemyBullets = G.enemyBullets.filter(b => {
    b.x += b.vx * dtSec;
    b.y += b.vy * dtSec;
    b.life -= dt;
    if (b.life <= 0) {
      if (b.isRocket) explodeAt(b.x, b.y, b.proxDmg, b.proxRadius, '#f80');
      return false;
    }
    // Proximity detonation for rockets
    if (b.isRocket && p.invincibleTimer <= 0 && dist(b, p) < b.proxRadius * 0.55) {
      explodeAt(b.x, b.y, b.proxDmg, b.proxRadius, '#f80');
      return false;
    }
    if (!b.isRocket && p.invincibleTimer <= 0 && dist(b, p) < p.r + b.r) {
      takeDamage(b.damage);
      spawnParticles(G, b.x, b.y, '#f00', 5, 30, 100, 150, 300);
      return false;
    }
    return true;
  });

  for (let i = G.enemies.length - 1; i >= 0; i--) {
    const e = G.enemies[i];
    if (e.hp <= 0) {
      // Kamikaze drone and heli explode on death too
      if (e.type === 'edrone') {
        explodeAt(e.x, e.y, e.explodeDmg, 90, '#f60');
      } else if (e.type === 'heli') {
        explodeAt(e.x, e.y, e.rocketDmg * 0.8, 100, '#f80');
      }
      killEnemy(e, i);
      continue;
    }

    // --- Kamikaze drone ---
    if (e.type === 'edrone') {
      e.spinAngle += dtSec * 6;
      const a = angle(e, p);
      e.x += Math.cos(a) * e.speed * dtSec;
      e.y += Math.sin(a) * e.speed * dtSec;
      e.x = Math.max(e.r, Math.min(G.mapW - e.r, e.x));
      e.y = Math.max(e.r, Math.min(G.mapH - e.r, e.y));
      if (p.invincibleTimer <= 0 && dist(e, p) < e.r + p.r + 4) {
        explodeAt(e.x, e.y, e.explodeDmg, 90, '#f60');
        e.hp = 0; // will be cleaned up next frame
      }
      continue;
    }

    // --- Helicopter ---
    if (e.type === 'heli') {
      e.rotorAngle += dtSec * 8;
      const a = angle(e, p);
      const d = dist(e, p);
      const hoverDist = 280;
      // Strafe sideways when at hover distance
      const perpAngle = a + Math.PI / 2;
      const strafeDir = Math.sin(G.time * 0.001) > 0 ? 1 : -1;
      if (d > hoverDist + 40) {
        e.x += Math.cos(a) * e.speed * dtSec;
        e.y += Math.sin(a) * e.speed * dtSec;
      } else if (d < hoverDist - 40) {
        e.x -= Math.cos(a) * e.speed * 0.5 * dtSec;
        e.y -= Math.sin(a) * e.speed * 0.5 * dtSec;
      } else {
        e.x += Math.cos(perpAngle) * strafeDir * e.speed * 0.6 * dtSec;
        e.y += Math.sin(perpAngle) * strafeDir * e.speed * 0.6 * dtSec;
      }
      e.x = Math.max(e.r, Math.min(G.mapW - e.r, e.x));
      e.y = Math.max(e.r, Math.min(G.mapH - e.r, e.y));
      e.fireTimer -= dt;
      if (e.fireTimer <= 0 && d <= e.range) {
        const ang = angle(e, p) + (Math.random() - 0.5) * 0.18;
        const sp = 260;
        G.enemyBullets.push({
          x: e.x, y: e.y,
          vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp,
          damage: e.rocketDmg, r: 7,
          life: (e.range / sp) * 1000 + 400,
          color: '#f80', proxDmg: e.rocketDmg, proxRadius: 110,
          isRocket: true,
        });
        e.fireTimer = e.fireRate;
      }
      continue;
    }

    // --- Standard enemies (soldier, heavy, vehicle) ---
    const a = angle(e, p);
    let ax = Math.cos(a), ay = Math.sin(a);
    G.enemies.forEach((o, j) => {
      if (j === i) return;
      const d = dist(e, o);
      if (d < e.r + o.r + 4) {
        ax -= (o.x - e.x) / d * 0.6;
        ay -= (o.y - e.y) / d * 0.6;
      }
    });
    const mv = norm({x: ax, y: ay});
    const stopDist = e.type === 'vehicle' ? 180 : 140;
    if (dist(e, p) > stopDist) {
      e.x += mv.x * e.speed * dtSec;
      e.y += mv.y * e.speed * dtSec;
    }
    e.x = Math.max(e.r, Math.min(G.mapW - e.r, e.x));
    e.y = Math.max(e.r, Math.min(G.mapH - e.r, e.y));
    e.fireTimer -= dt;
    if (e.fireTimer <= 0 && dist(e, p) <= e.range) {
      const ang = angle(e, p);
      const sp = 260 + Math.random() * 60;
      G.enemyBullets.push({ x: e.x, y: e.y, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp, damage: e.damage, r: 4, life: (e.range / sp) * 1000 + 200, color: '#f44' });
      e.fireTimer = e.fireRate;
    }
    if (p.invincibleTimer <= 0 && dist(e, p) < e.r + p.r + 2) {
      takeDamage(e.damage * 0.5);
      p.invincibleTimer = 500;
    }
  }

  allDogs(G).forEach(dog => updateDog(dog, dtSec));

  if (G.drones && G.drones.length > 0) {
    G.drones.forEach(drone => updateDrone(drone, dtSec));
    G.drone = G.drones[0] || null;
  } else if (G.drone) {
    updateDrone(G.drone, dtSec);
  }

  G.particles = G.particles.filter(p => {
    p.x += p.vx * dtSec;
    p.y += p.vy * dtSec;
    p.vx *= 0.94;
    p.vy *= 0.94;
    p.life -= dt;
    return p.life > 0;
  });

  G.boats = G.boats.filter(b => { b.life -= dt; return b.life > 0; });

  G.floatTexts = G.floatTexts.filter(t => {
    t.y -= 28 * dtSec;
    t.life -= dt;
    return t.life > 0;
  });

  document.getElementById('hp-val').textContent = Math.ceil(p.hp) + '/' + p.maxHp;
  document.getElementById('coins-val').textContent = G.coins;
  document.getElementById('score-val').textContent = G.score;
  document.getElementById('kills-val').textContent = G.kills;

  let cs = '';
  const dogs = allDogs(G);
  if (dogs.length > 0) cs += (dogs.length === 1 ? 'Rex: aktiv' : 'Rex + Buddy: aktiv') + '  ';
  if (G.drones && G.drones.length > 0) {
    cs += 'Droner: ' + G.drones.length;
  } else if (G.drone) {
    cs += 'Drone: aktiv';
  }
  document.getElementById('companion-status').textContent = cs;
}

function getCurrentWeapon() {
  const p = G.player;
  const wname = p.weapons[p.weaponIdx] || 'pistol';
  const base = WEAPON_DEFS.find(w => w.id === wname) || WEAPON_DEFS[0];
  const mults = (G.wpnMults && G.wpnMults[base.id]) || { dmg: 1, rate: 1 };
  return Object.assign({}, base, {
    damage: base.damage * mults.dmg,
    rate: base.rate * mults.rate,
  });
}

function nearestEnemy(from) {
  let best = null, bestD = Infinity;
  G.enemies.forEach(e => {
    const d = dist(from, e);
    if (d < bestD) { bestD = d; best = e; }
  });
  return best;
}

function fireWeapon(shooter, target, wdef) {
  const baseAngle = angle(shooter, target);
  for (let i = 0; i < wdef.bullets; i++) {
    const a = baseAngle + (Math.random() - 0.5) * wdef.spread * 2;
    const lifeMs = (wdef.range / wdef.speed) * 1000 + 100;
    const isFlame = wdef.flame || false;
    const isExplosive = wdef.explosive || false;
    G.bullets.push({
      x: shooter.x, y: shooter.y,
      vx: Math.cos(a) * wdef.speed, vy: Math.sin(a) * wdef.speed,
      damage: wdef.damage, r: isFlame ? 5 : (isExplosive ? 7 : 4),
      life: lifeMs, explosive: isExplosive, flame: isFlame,
      color: isFlame ? '#f50' : (isExplosive ? '#f80' : COLORS.bullet),
      pierce: false,
    });
  }
}

function hitEnemy(e, dmg) {
  e.hp -= dmg;
  G.floatTexts.push({ x: e.x, y: e.y - e.r, text: '-' + Math.ceil(dmg), life: 600, color: '#ff0', size: 12 });
}

function explodeAt(x, y, dmg, radius, color) {
  spawnParticles(G, x, y, color || '#f80', 22, 80, 260, 300, 700, 4, 10);
  spawnParticles(G, x, y, '#fff', 8, 40, 120, 100, 250, 2, 5);
  // Screen flash ring
  G.floatTexts.push({ x, y, text: '', life: 120, color: color || '#f80', size: 0, isBlast: true, blastR: radius });
  const p = G.player;
  const dToPlayer = dist({x, y}, p);
  if (p.invincibleTimer <= 0 && dToPlayer < radius) {
    const falloff = 1 - dToPlayer / radius;
    takeDamage(dmg * falloff);
    p.invincibleTimer = 400;
  }
  G.enemies.forEach(e => {
    const d = dist({x, y}, e);
    if (d < radius) hitEnemy(e, dmg * (1 - d / radius));
  });
}

function killEnemy(e, idx) {
  G.enemies.splice(idx, 1);
  G.kills++;
  G.score += e.score;
  G.coins += e.coins;
  spawnParticles(G, e.x, e.y, e.color, 12, 40, 160, 300, 700, 3, 6);
  G.floatTexts.push({ x: e.x, y: e.y - 20, text: '+' + e.coins, life: 900, color: '#ff0', size: 13 });
}

function takeDamage(dmg) {
  G.player.hp -= dmg;
  spawnParticles(G, G.player.x, G.player.y, '#f00', 8, 30, 120, 200, 500);
  if (G.player.hp <= 0) {
    G.gameOver = true;
    joyEnd();
    document.getElementById('go-wave').textContent = G.wave;
    document.getElementById('go-score').textContent = G.score;
    document.getElementById('go-kills').textContent = G.kills;
    document.getElementById('game-over').style.display = 'flex';
  }
}

function updateDog(dog, dtSec) {
  const canTarget = (e) => e.type !== 'vehicle' && e.type !== 'edrone' && e.type !== 'heli';
  if (!dog.target || dog.target.hp <= 0 || !canTarget(dog.target) || dist(dog, dog.target) > 300) {
    dog.target = G.enemies.filter(canTarget).reduce((best, e) => {
      const d = dist(dog, e);
      return (!best || d < dist(dog, best)) ? e : best;
    }, null);
  }
  if (dog.target) {
    const a = angle(dog, dog.target);
    // Approach a point perpendicular to the attack angle, offset by dog's side
    const sideSign = (dog.followOffsetY || 0) >= 0 ? 1 : -1;
    const perpX = dog.target.x + Math.sin(a) * 18 * sideSign;
    const perpY = dog.target.y - Math.cos(a) * 18 * sideSign;
    const dxP = perpX - dog.x;
    const dyP = perpY - dog.y;
    const dToSlot = Math.sqrt(dxP*dxP + dyP*dyP);
    const stopDist = dog.r + dog.target.r + 4;
    const d = dist(dog, dog.target);
    if (dToSlot > stopDist) {
      dog.x += (dxP/dToSlot) * dog.speed * dtSec;
      dog.y += (dyP/dToSlot) * dog.speed * dtSec;
    }
    dog.attackCooldown -= dtSec * 1000;
    if (dog.attackCooldown <= 0 && d < stopDist + 22) {
      hitEnemy(dog.target, dog.damage);
      dog.attackCooldown = dog.attackRate;
      spawnParticles(G, dog.x, dog.y, '#c82', 5, 20, 80, 150, 300);
    }
  } else {
    const targetX = G.player.x + (dog.followOffsetX || -35);
    const targetY = G.player.y + (dog.followOffsetY || 0);
    const dx = targetX - dog.x;
    const dy = targetY - dog.y;
    const d = Math.sqrt(dx*dx + dy*dy);
    if (d > 40) {
      // Full speed when far away
      dog.x += (dx/d) * dog.speed * dtSec;
      dog.y += (dy/d) * dog.speed * dtSec;
    } else if (d > 6) {
      // Slow lerp when close, prevents jitter
      const lerpSpeed = dog.speed * (d / 40);
      dog.x += (dx/d) * lerpSpeed * dtSec;
      dog.y += (dy/d) * lerpSpeed * dtSec;
    }
    // Dead zone: d <= 6, don't move at all
  }
}

function updateDrone(drone, dtSec) {
  drone.orbitAngle += dtSec * (drone.orbitSpeed || 1.5);
  drone.x = G.player.x + Math.cos(drone.orbitAngle) * drone.orbitRadius;
  drone.y = G.player.y + Math.sin(drone.orbitAngle) * drone.orbitRadius;
  drone.fireTimer -= dtSec * 1000;
  if (drone.fireTimer <= 0 && G.enemies.length > 0) {
    const target = nearestEnemy(drone);
    if (target && dist(drone, target) < 400) {
      fireWeapon(drone, target, { damage: drone.damage, speed: 480, range: 400, spread: 0.04, bullets: 1, explosive: false });
      drone.fireTimer = drone.fireRate;
    }
  }
}

// ========== RENDER ==========
function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(-G.camX, -G.camY);

  const cx = G.mapW / 2, cy = G.mapH / 2;
  const idef = ISLAND_DEFS[G.islandIdx];
  const islandRx = G.mapW * idef.rx, islandRy = G.mapH * idef.ry;
  const islandTilt = idef.tilt;

  // Ocean background
  ctx.fillStyle = '#0a2a4a';
  ctx.fillRect(0, 0, G.mapW, G.mapH);

  // Animated wave shimmer
  const wt = G.time * 0.0008;
  for (let i = 0; i < 18; i++) {
    const wx = (i * 197 + Math.sin(wt + i * 0.7) * 80) % G.mapW;
    const wy = (i * 139 + Math.cos(wt * 0.6 + i * 1.1) * 60) % G.mapH;
    const wr = 60 + Math.sin(wt * 1.3 + i) * 20;
    ctx.globalAlpha = 0.06 + Math.sin(wt + i) * 0.03;
    ctx.fillStyle = '#5af';
    ctx.beginPath();
    ctx.ellipse(wx, wy, wr, wr * 0.3, wt * 0.2 + i, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Island sandy beach ring
  ctx.fillStyle = idef.sand;
  ctx.beginPath();
  ctx.ellipse(cx, cy, islandRx + idef.beach, islandRy + idef.beach, islandTilt, 0, Math.PI * 2);
  ctx.fill();

  // Island grass
  ctx.fillStyle = idef.grass;
  ctx.beginPath();
  ctx.ellipse(cx, cy, islandRx, islandRy, islandTilt, 0, Math.PI * 2);
  ctx.fill();

  // Grass texture patches
  for (let i = 0; i < 40; i++) {
    const ang = i * 2.4 + islandTilt;
    const px = cx + Math.cos(ang) * islandRx * (0.2 + (i % 7) * 0.1);
    const py = cy + Math.sin(ang) * islandRy * (0.2 + (i % 5) * 0.12);
    ctx.fillStyle = i % 3 === 0 ? idef.grassDark : idef.grass;
    ctx.beginPath();
    ctx.ellipse(px, py, 18 + (i % 4) * 8, 12 + (i % 3) * 6, i * 0.5, 0, Math.PI * 2);
    ctx.fill();
  }

  // Shoreline foam
  ctx.strokeStyle = 'rgba(200,220,255,0.25)';
  ctx.lineWidth = 8;
  ctx.setLineDash([30, 20]);
  ctx.beginPath();
  ctx.ellipse(cx, cy, islandRx + idef.beach + 3, islandRy + idef.beach + 3, islandTilt, 0, Math.PI * 2);
  ctx.stroke();
  ctx.setLineDash([]);

  // Boats (visual objects stored in G.boats)
  if (G.boats) {
    G.boats.forEach(boat => {
      ctx.save();
      ctx.translate(boat.x, boat.y);
      ctx.rotate(boat.angle);
      ctx.fillStyle = '#6b4226';
      ctx.beginPath();
      ctx.ellipse(0, 0, 28, 10, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#8b5a3c';
      ctx.fillRect(-12, -14, 8, 14);
      ctx.fillStyle = 'rgba(200,200,200,0.7)';
      ctx.beginPath();
      ctx.moveTo(-8, -14); ctx.lineTo(10, -6); ctx.lineTo(-8, -2);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    });
  }
  // Particles
  G.particles.forEach(p => {
    const alpha = p.life / 600;
    ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  allDogs(G).forEach(dog => drawDog(dog));

  if (G.drones && G.drones.length > 0) {
    G.drones.forEach(d => drawDrone(d));
  } else if (G.drone) {
    drawDrone(G.drone);
  }

  G.enemies.forEach(e => drawEnemy(e));
  drawPlayer(G.player);

  G.bullets.forEach(b => {
    if (b.flame) {
      ctx.globalAlpha = 0.75 + Math.random() * 0.25;
      ctx.shadowBlur = 10;
      ctx.shadowColor = '#ff6600';
      ctx.fillStyle = b.life > 150 ? '#ff8800' : '#ffcc00';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r * (0.6 + Math.random() * 0.8), 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    } else {
      ctx.shadowBlur = 8;
      ctx.shadowColor = b.color;
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();
    }
  });
  ctx.shadowBlur = 0;

  G.enemyBullets.forEach(b => {
    if (b.isRocket) {
      const ang = Math.atan2(b.vy, b.vx);
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(ang);
      // Exhaust flame (behind rocket)
      ctx.shadowBlur = 14;
      ctx.shadowColor = '#ff6600';
      ctx.fillStyle = '#ffcc00';
      ctx.beginPath();
      ctx.ellipse(-10, 0, 9, 3, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ff4400';
      ctx.beginPath();
      ctx.ellipse(-13, 0, 5, 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      // Rocket body
      ctx.fillStyle = '#cccccc';
      ctx.beginPath();
      ctx.roundRect(-7, -3, 14, 6, 2);
      ctx.fill();
      // Nose cone
      ctx.fillStyle = '#ff4400';
      ctx.beginPath();
      ctx.moveTo(7, 0);
      ctx.lineTo(3, -3);
      ctx.lineTo(3, 3);
      ctx.closePath();
      ctx.fill();
      // Tail fins
      ctx.fillStyle = '#999999';
      ctx.beginPath();
      ctx.moveTo(-7, -3); ctx.lineTo(-11, -6); ctx.lineTo(-7, -1); ctx.closePath(); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-7, 3); ctx.lineTo(-11, 6); ctx.lineTo(-7, 1); ctx.closePath(); ctx.fill();
      ctx.restore();
    } else {
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
      ctx.fill();
    }
  });

  G.floatTexts.forEach(t => {
    ctx.globalAlpha = Math.min(1, t.life / 300);
    ctx.fillStyle = t.color;
    ctx.font = 'bold ' + (t.size || 13) + 'px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(t.text, t.x, t.y);
  });
  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';

  ctx.restore();

  // HUD health bar
  const barW = 180, barH = 10;
  const bx = 10, by = 90;
  ctx.fillStyle = '#222';
  ctx.fillRect(bx, by, barW, barH);
  const hpFrac = Math.max(0, G.player.hp / G.player.maxHp);
  const hpColor = hpFrac > 0.5 ? '#0f0' : hpFrac > 0.25 ? '#ff0' : '#f00';
  ctx.fillStyle = hpColor;
  ctx.fillRect(bx, by, barW * hpFrac, barH);
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  ctx.strokeRect(bx, by, barW, barH);

  // Virtual joystick (touch only)
  if (joystick.active || 'ontouchstart' in window) {
    const jR = 55, nR = 22;
    const jx = joystick.active ? joystick.baseX : jR + 24;
    const jy = joystick.active ? joystick.baseY : canvas.height - jR - 24;
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(jx, jy, jR, 0, Math.PI * 2); ctx.stroke();
    ctx.globalAlpha = joystick.active ? 0.7 : 0.2;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(jx + joystick.dx * jR, jy + joystick.dy * jR, nR, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Island transition fade overlay
  if (G.islandTransition > 0) {
    const alpha = Math.min(1, G.islandTransition / 600);
    ctx.globalAlpha = alpha * 0.85;
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 28px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(ISLAND_DEFS[G.islandIdx].name, canvas.width / 2, canvas.height / 2);
    ctx.font = '16px Courier New';
    ctx.fillText('EXTRACTING...', canvas.width / 2, canvas.height / 2 + 36);
    ctx.textAlign = 'left';
    ctx.globalAlpha = 1;
  }
}

// ========== DRAW FUNCTIONS ==========

function drawSoldierTopDown(s, helmetColor, shoulderColor, vestColor, skinColor, eyeColor) {
  const f = s;

  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.beginPath();
  ctx.ellipse(1*f, 1*f, 9*f, 9*f, 0, 0, Math.PI*2);
  ctx.fill();

  // Left shoulder
  ctx.fillStyle = shoulderColor;
  ctx.beginPath();
  ctx.ellipse(-1*f, -8*f, 5*f, 3.5*f, 0.4, 0, Math.PI*2);
  ctx.fill();

  // Right shoulder
  ctx.beginPath();
  ctx.ellipse(-1*f, 8*f, 5*f, 3.5*f, -0.4, 0, Math.PI*2);
  ctx.fill();

  // Weapon (pointing forward = positive x)
  ctx.fillStyle = '#1a1a1a';
  ctx.beginPath();
  ctx.roundRect(4*f, -1.4*f, 16*f, 2.8*f, 1);
  ctx.fill();
  // Barrel highlight
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.roundRect(13*f, -0.8*f, 7*f, 1.6*f, 1);
  ctx.fill();
  // Muzzle
  ctx.fillStyle = '#555';
  ctx.beginPath();
  ctx.arc(20*f, 0, 1.4*f, 0, Math.PI*2);
  ctx.fill();

  // Helmet base (main dome seen from above)
  ctx.fillStyle = helmetColor;
  ctx.beginPath();
  ctx.arc(0, 0, 8*f, 0, Math.PI*2);
  ctx.fill();

  // Helmet rim / edge shadow
  ctx.strokeStyle = 'rgba(0,0,0,0.55)';
  ctx.lineWidth = 1.4*f;
  ctx.beginPath();
  ctx.arc(0, 0, 8*f, 0, Math.PI*2);
  ctx.stroke();

  // Helmet gloss highlight
  const grad = ctx.createRadialGradient(-3*f, -3*f, 0.5*f, 0, 0, 8*f);
  grad.addColorStop(0,   'rgba(255,255,255,0.22)');
  grad.addColorStop(0.5, 'rgba(255,255,255,0.04)');
  grad.addColorStop(1,   'rgba(0,0,0,0.3)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(0, 0, 8*f, 0, Math.PI*2);
  ctx.fill();
}

function drawPlayer(p) {
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(p.facing);
  drawSoldierTopDown(1.0, '#2e4a2a', '#2a3a28', '#3a5035', '#b08060', '#1a4a5a');
   ctx.shadowBlur = 0;
   ctx.restore();
}

function drawEnemy(e) {
  ctx.save();
  ctx.translate(e.x, e.y);

  if (e.type === 'edrone') {
    drawEnemyDrone(e);
    ctx.restore();
    // HP bar
    ctx.save();
    ctx.translate(e.x, e.y);
    const bw = e.r * 2.4;
    ctx.fillStyle = '#400'; ctx.fillRect(-bw/2, -e.r-10, bw, 5);
    ctx.fillStyle = '#f40'; ctx.fillRect(-bw/2, -e.r-10, bw * Math.max(0, e.hp/e.maxHp), 5);
    ctx.restore();
    return;
  }

  if (e.type === 'heli') {
    drawEnemyHeli(e);
    ctx.restore();
    // HP bar
    ctx.save();
    ctx.translate(e.x, e.y);
    const bw = e.r * 2.4;
    ctx.fillStyle = '#400'; ctx.fillRect(-bw/2, -e.r-12, bw, 5);
    ctx.fillStyle = '#f80'; ctx.fillRect(-bw/2, -e.r-12, bw * Math.max(0, e.hp/e.maxHp), 5);
    ctx.restore();
    return;
  }

  if (e.type === 'vehicle') {
    ctx.fillStyle = e.color;
    ctx.beginPath();
    ctx.roundRect(-e.r, -e.r * 0.6, e.r * 2, e.r * 1.2, 3);
    ctx.fill();
    ctx.strokeStyle = '#c84';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.fillStyle = '#885522';
    ctx.beginPath();
    ctx.arc(0, 0, e.r * 0.5, 0, Math.PI * 2);
    ctx.fill();
    const a2 = angle(e, G.player);
    ctx.strokeStyle = '#664422';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(Math.cos(a2) * e.r * 1.1, Math.sin(a2) * e.r * 1.1);
    ctx.stroke();
  } else {
    const a2 = angle(e, G.player);
    ctx.rotate(a2);
    const s = e.type === 'heavy' ? 1.35 : 1.0;
    if (e.type === 'heavy') {
      drawSoldierTopDown(s, '#3a2008', '#5a3010', '#7a4820', '#b07050', '#ff3333');
    } else {
      drawSoldierTopDown(s, '#3a0808', '#6b2020', '#8b3030', '#b07050', '#ff3333');
    }
  }

  ctx.restore();

  ctx.save();
  ctx.translate(e.x, e.y);
  const bw = e.r * 2.4;
  ctx.fillStyle = '#400';
  ctx.fillRect(-bw / 2, -e.r - 10, bw, 5);
  ctx.fillStyle = '#f00';
  ctx.fillRect(-bw / 2, -e.r - 10, bw * Math.max(0, e.hp / e.maxHp), 5);
  ctx.strokeStyle = '#600';
  ctx.lineWidth = 0.5;
  ctx.strokeRect(-bw / 2, -e.r - 10, bw, 5);
  ctx.restore();
}

function drawEnemyDrone(e) {
  // Fast-spinning kamikaze drone â€” orange/red hostile colours
  const spin = e.spinAngle;
  const armLen = 10;
  const armAngles = [Math.PI*0.25, Math.PI*0.75, Math.PI*1.25, Math.PI*1.75];

  // Glow
  ctx.shadowBlur = 14;
  ctx.shadowColor = '#ff4400';

  ctx.save();
  ctx.rotate(spin);

  // Arms
  ctx.strokeStyle = '#5a1800';
  ctx.lineWidth = 2.5;
  ctx.lineCap = 'round';
  for (let aa of armAngles) {
    ctx.beginPath();
    ctx.moveTo(Math.cos(aa)*3, Math.sin(aa)*3);
    ctx.lineTo(Math.cos(aa)*armLen, Math.sin(aa)*armLen);
    ctx.stroke();
  }

  // Nacelles
  for (let aa of armAngles) {
    const hx = Math.cos(aa)*armLen, hy = Math.sin(aa)*armLen;
    ctx.fillStyle = '#3a0800';
    ctx.strokeStyle = '#aa3300';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(hx, hy, 4.5, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    // Rotor blur disc
    ctx.fillStyle = 'rgba(255,80,0,0.15)';
    ctx.beginPath(); ctx.arc(hx, hy, 6, 0, Math.PI*2); ctx.fill();
  }

  // Central body hex
  ctx.fillStyle = '#2a0a00';
  ctx.strokeStyle = '#cc3300';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  for (let hi = 0; hi < 6; hi++) {
    const ha = (hi/6)*Math.PI*2 - Math.PI/6;
    const hx = Math.cos(ha)*5.5, hy = Math.sin(ha)*5.5;
    hi === 0 ? ctx.moveTo(hx, hy) : ctx.lineTo(hx, hy);
  }
  ctx.closePath(); ctx.fill(); ctx.stroke();

  ctx.restore();

  // Warning light blink
  const blink = Math.sin(G.time * 0.018) > 0;
  ctx.fillStyle = blink ? '#ff2200' : '#330000';
  ctx.shadowBlur = blink ? 10 : 0;
  ctx.shadowColor = '#ff2200';
  ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();
  ctx.shadowBlur = 0;
}

function drawEnemyHeli(e) {
  const rot = e.rotorAngle;
  const aToPlayer = angle(e, G.player);

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.beginPath();
  ctx.ellipse(4, 6, 22, 14, 0, 0, Math.PI*2);
  ctx.fill();

  ctx.save();
  ctx.rotate(aToPlayer);

  // Fuselage â€” elongated olive body
  ctx.fillStyle = '#4a3800';
  ctx.strokeStyle = '#6a5010';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.ellipse(0, 0, e.r*0.85, e.r*0.45, 0, 0, Math.PI*2);
  ctx.fill(); ctx.stroke();

  // Tail boom
  ctx.strokeStyle = '#5a4800';
  ctx.lineWidth = 4;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(-e.r*0.7, 0);
  ctx.lineTo(-e.r*1.6, 0);
  ctx.stroke();

  // Cockpit (front)
  ctx.fillStyle = '#222a10';
  ctx.strokeStyle = '#3a4a18';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.ellipse(e.r*0.5, 0, e.r*0.38, e.r*0.32, 0, 0, Math.PI*2);
  ctx.fill(); ctx.stroke();
  // Cockpit glass
  ctx.fillStyle = 'rgba(80,180,255,0.5)';
  ctx.beginPath();
  ctx.ellipse(e.r*0.55, -e.r*0.05, e.r*0.22, e.r*0.18, -0.2, 0, Math.PI*2);
  ctx.fill();

  // Skids
  ctx.strokeStyle = '#3a3000';
  ctx.lineWidth = 2;
  for (const sy of [-e.r*0.38, e.r*0.38]) {
    ctx.beginPath();
    ctx.moveTo(-e.r*0.5, sy);
    ctx.lineTo(e.r*0.6, sy);
    ctx.stroke();
  }

  // Main rotor hub
  ctx.fillStyle = '#1a1200';
  ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill();

  ctx.restore();

  // Main rotor blades â€” spin independently of body
  ctx.save();
  ctx.rotate(rot);
  ctx.strokeStyle = 'rgba(80,60,0,0.75)';
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';
  for (let bi = 0; bi < 2; bi++) {
    const ba = bi * Math.PI;
    ctx.beginPath();
    ctx.moveTo(Math.cos(ba)*3, Math.sin(ba)*3);
    ctx.lineTo(Math.cos(ba)*e.r*1.55, Math.sin(ba)*e.r*1.55);
    ctx.stroke();
  }
  // Rotor disc blur
  ctx.fillStyle = 'rgba(80,60,0,0.08)';
  ctx.beginPath(); ctx.arc(0, 0, e.r*1.55, 0, Math.PI*2); ctx.fill();
  ctx.restore();

  // Tail rotor
  ctx.save();
  const tailX = Math.cos(angle(e, G.player) + Math.PI) * e.r * 1.6;
  const tailY = Math.sin(angle(e, G.player) + Math.PI) * e.r * 1.6;
  ctx.translate(tailX, tailY);
  ctx.rotate(rot * 3);
  ctx.strokeStyle = 'rgba(80,60,0,0.6)';
  ctx.lineWidth = 2;
  for (let bi = 0; bi < 2; bi++) {
    const ba = bi * Math.PI;
    ctx.beginPath();
    ctx.moveTo(Math.cos(ba)*2, Math.sin(ba)*2);
    ctx.lineTo(Math.cos(ba)*7, Math.sin(ba)*7);
    ctx.stroke();
  }
  ctx.restore();
}

function drawDog(dog) {
  ctx.save();
  ctx.translate(dog.x, dog.y);
  const dogTarget = dog.target && dog.target.hp > 0 ? dog.target : G.player;
  ctx.rotate(angle(dog, dogTarget));
  const waggle = Math.sin(G.time * 0.012) * 0.5;

  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(0, 0, 12, 7, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.save();
  ctx.translate(-9, 0);
  ctx.rotate(waggle);
  ctx.fillStyle = '#b07030';
  ctx.beginPath();
  ctx.moveTo(0, -2);
  ctx.quadraticCurveTo(-6, -6, -10, -2);
  ctx.quadraticCurveTo(-12, 0, -10, 2);
  ctx.quadraticCurveTo(-6, 6, 0, 2);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#d09050';
  ctx.beginPath();
  ctx.ellipse(-10, 0, 2.5, 2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  ctx.fillStyle = '#a06828';
  ctx.beginPath();
  ctx.ellipse(-5, -6, 4, 2.5, 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(-5, 6, 4, 2.5, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.ellipse(-2, -6, 2.5, 1.8, 0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(-2, 6, 2.5, 1.8, -0.2, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#c8822a';
  ctx.beginPath();
  ctx.ellipse(0, 0, 9, 6, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#a06020';
  ctx.beginPath();
  ctx.ellipse(-1, 0, 5, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#e0a050';
  ctx.beginPath();
  ctx.ellipse(1, 0, 5, 2.5, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#c8822a';
  ctx.beginPath();
  ctx.ellipse(5, -6, 4, 2.5, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(5, 6, 4, 2.5, 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.ellipse(2, -6, 2.5, 1.8, -0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(2, 6, 2.5, 1.8, 0.2, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#c8822a';
  ctx.beginPath();
  ctx.ellipse(9, 0, 4, 4.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#cc2222';
  ctx.beginPath();
  ctx.ellipse(8, 0, 3.5, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#c8822a';
  ctx.beginPath();
  ctx.ellipse(8, 0, 2.5, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#ffaa00';
  ctx.beginPath();
  ctx.arc(7, 4, 1.5, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#d89040';
  ctx.beginPath();
  ctx.ellipse(13, 0, 6, 5.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#a86020';
  ctx.beginPath();
  ctx.ellipse(12, -7, 3, 5, 0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(12, 7, 3, 5, -0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#b87030';
  ctx.beginPath();
  ctx.ellipse(17, 0, 4, 3, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.ellipse(20, 0, 2, 1.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#555';
  ctx.beginPath();
  ctx.arc(20, 0, 0.7, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(13, -4.5, 1.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(13, 4.5, 1.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(13.5, -5, 0.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(13.5, 4, 0.5, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawDrone(drone) {
  // Military quadcopter viewed from above.
  // Body frame rotates slowly. Gun turret always aims at nearest enemy.
  const bodyAngle = G.time * 0.0015;
  const target = nearestEnemy(drone);
  const gunAngle = target ? angle(drone, target) : drone.orbitAngle + Math.PI;
  const rotorSpin = G.time * 0.022;

  ctx.save();
  ctx.translate(drone.x, drone.y);

  // Drop shadow on ground
  ctx.fillStyle = 'rgba(0,0,0,0.30)';
  ctx.beginPath();
  ctx.ellipse(3, 4, 20, 15, 0, 0, Math.PI * 2);
  ctx.fill();

  // ---- Rotating body frame ----
  ctx.save();
  ctx.rotate(bodyAngle);

  // 4 arms at 45Â° (X shape)
  var armLen = 14;
  var armAngles = [
    Math.PI * 0.25,
    Math.PI * 0.75,
    Math.PI * 1.25,
    Math.PI * 1.75
  ];

  // Arm struts
  ctx.strokeStyle = '#2a3828';
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';
  for (var ai = 0; ai < 4; ai++) {
    var aa = armAngles[ai];
    ctx.beginPath();
    ctx.moveTo(Math.cos(aa) * 4, Math.sin(aa) * 4);
    ctx.lineTo(Math.cos(aa) * armLen, Math.sin(aa) * armLen);
    ctx.stroke();
  }
  // Arm highlight edge
  ctx.strokeStyle = '#3a5035';
  ctx.lineWidth = 1;
  for (var ai = 0; ai < 4; ai++) {
    var aa = armAngles[ai];
    ctx.beginPath();
    ctx.moveTo(Math.cos(aa) * 4, Math.sin(aa) * 4);
    ctx.lineTo(Math.cos(aa) * armLen, Math.sin(aa) * armLen);
    ctx.stroke();
  }

  // Motor nacelles + spinning rotors
  for (var ri = 0; ri < 4; ri++) {
    var ra = armAngles[ri];
    var hx = Math.cos(ra) * armLen;
    var hy = Math.sin(ra) * armLen;

    // Nacelle (motor housing)
    ctx.fillStyle = '#1e2e1e';
    ctx.strokeStyle = '#3a5030';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.arc(hx, hy, 5.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // Inner ring
    ctx.strokeStyle = '#4a6040';
    ctx.lineWidth = 0.8;
    ctx.beginPath();
    ctx.arc(hx, hy, 3.5, 0, Math.PI * 2);
    ctx.stroke();

    // Spinning rotor blades (2 blades, 90 degrees apart)
    var spin = rotorSpin + ri * (Math.PI / 2);
    ctx.save();
    ctx.translate(hx, hy);
    ctx.rotate(spin);

    // Blade 1
    ctx.fillStyle = 'rgba(120,210,140,0.50)';
    ctx.beginPath();
    ctx.ellipse(0, 0, 6, 1.4, 0, 0, Math.PI * 2);
    ctx.fill();
    // Blade 2
    ctx.rotate(Math.PI / 2);
    ctx.beginPath();
    ctx.ellipse(0, 0, 6, 1.4, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Rotor disc blur
    ctx.fillStyle = 'rgba(80,200,100,0.07)';
    ctx.beginPath();
    ctx.arc(hx, hy, 6.5, 0, Math.PI * 2);
    ctx.fill();
  }

  // Central hexagonal frame plate
  ctx.fillStyle = '#192818';
  ctx.strokeStyle = '#304828';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  for (var hi = 0; hi < 6; hi++) {
    var ha = (hi / 6) * Math.PI * 2 - Math.PI / 6;
    var px = Math.cos(ha) * 7;
    var py = Math.sin(ha) * 7;
    if (hi === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // Plate surface detail lines
  ctx.strokeStyle = 'rgba(80,160,80,0.25)';
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(-5, 0); ctx.lineTo(5, 0);
  ctx.moveTo(-2.5, -4.3); ctx.lineTo(2.5, 4.3);
  ctx.moveTo(2.5, -4.3); ctx.lineTo(-2.5, 4.3);
  ctx.stroke();

  // Camera pod / dome
  ctx.fillStyle = '#0c140c';
  ctx.strokeStyle = '#2a3a22';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(0, 0, 4.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  // Camera lens
  ctx.fillStyle = 'rgba(60,180,255,0.70)';
  ctx.beginPath();
  ctx.arc(-0.5, -0.5, 2, 0, Math.PI * 2);
  ctx.fill();
  // Lens glint
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.beginPath();
  ctx.arc(-1, -1, 0.7, 0, Math.PI * 2);
  ctx.fill();

  // Nav lights on two arm tips (blink at different rates)
  var blink1 = Math.sin(G.time * 0.009) > 0;
  var blink2 = Math.sin(G.time * 0.009 + Math.PI) > 0;
  // Green - starboard (arm 0)
  ctx.fillStyle = blink1 ? '#00ee66' : '#003318';
  ctx.shadowBlur = blink1 ? 5 : 0;
  ctx.shadowColor = '#00ee66';
  ctx.beginPath();
  ctx.arc(Math.cos(armAngles[0]) * armLen, Math.sin(armAngles[0]) * armLen, 2, 0, Math.PI * 2);
  ctx.fill();
  // Red - port (arm 1)
  ctx.fillStyle = blink2 ? '#ff3333' : '#440000';
  ctx.shadowColor = '#ff3333';
  ctx.shadowBlur = blink2 ? 5 : 0;
  ctx.beginPath();
  ctx.arc(Math.cos(armAngles[1]) * armLen, Math.sin(armAngles[1]) * armLen, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;

  ctx.restore(); // end body rotation

  // ---- Gun turret â€” always faces nearest enemy ----
  ctx.save();
  ctx.rotate(gunAngle);

  // Turret base (small flat disc under body)
  ctx.fillStyle = '#151e12';
  ctx.strokeStyle = '#2a3820';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.ellipse(0, 0, 4, 3, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  // Gun barrel
  ctx.fillStyle = '#1a2218';
  ctx.strokeStyle = '#2a3520';
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.roundRect(1, -1.1, 14, 2.2, 1);
  ctx.fill();
  ctx.stroke();

  // Barrel rib detail
  ctx.strokeStyle = 'rgba(100,150,80,0.4)';
  ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(4, -1.1); ctx.lineTo(4, 1.1);
  ctx.moveTo(8, -1.1); ctx.lineTo(8, 1.1);
  ctx.moveTo(12, -1.1); ctx.lineTo(12, 1.1);
  ctx.stroke();

  // Muzzle cap
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(15, 0, 1.4, 0, Math.PI * 2);
  ctx.fill();

  // Muzzle flash (briefly after firing)
  if (drone.fireTimer !== undefined && drone.fireTimer > drone.fireRate - 90) {
    ctx.save();
    ctx.shadowBlur = 8;
    ctx.shadowColor = '#ffe060';
    ctx.fillStyle = 'rgba(255,230,60,0.92)';
    ctx.beginPath();
    // Star-ish flash shape
    ctx.arc(17, 0, 3.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,200,0.7)';
    ctx.beginPath();
    ctx.arc(17, 0, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.restore();
  }

  ctx.restore(); // end gun rotation

   ctx.restore(); // end translate
}

// ========== SHOP ==========
function openShop() {
  G.shopOpen = true;
  document.getElementById('shop-overlay').style.display = 'block';
  renderShop();
}

function closeShop() {
  G.shopOpen = false;
  document.getElementById('shop-overlay').style.display = 'none';
  buildWeaponBar();
}

function renderShop(expandedWeaponSection) {
  document.getElementById('shop-coins-val').textContent = G.coins;
  const content = document.getElementById('shop-content');
  content.innerHTML = '';

  // First pass: collect all weapon sections (those with wpnUpgrade entries)
  const weaponSections = {}; // section -> { unlock, dmg, rate, weaponId }
  UPGRADES.forEach(upg => {
    if (upg.wpnUpgrade) {
      if (!weaponSections[upg.section]) weaponSections[upg.section] = {};
      const key = upg.id.endsWith('_dmg') ? 'dmg' : 'rate';
      weaponSections[upg.section][key] = upg;
      // Extract weapon id from upgrade id: e.g. "buy_rifle_dmg" -> "rifle", "pistol_wpn_dmg" -> "pistol"
      if (!weaponSections[upg.section].weaponId) {
        const m = upg.id.match(/^(?:buy_)?(\w+?)(?:_wpn)?_(?:dmg|rate)$/);
        if (m) weaponSections[upg.section].weaponId = m[1];
      }
    }
  });
  // Second pass: attach unlock entries to weapon sections
  const otherSections = {};
  UPGRADES.forEach(upg => {
    if (upg.wpnUpgrade) return; // already handled
    if (weaponSections[upg.section]) {
      if (!weaponSections[upg.section].unlock) weaponSections[upg.section].unlock = upg;
    } else {
      if (!otherSections[upg.section]) otherSections[upg.section] = [];
      otherSections[upg.section].push(upg);
    }
  });

  function wpnStatsHtml(weaponId) {
    const wdef = WEAPON_DEFS.find(w => w.id === weaponId);
    if (!wdef) return '';
    const sps = (1000 / wdef.rate).toFixed(1);
    const dmg = wdef.bullets > 1 ? wdef.damage + ' x' + wdef.bullets : wdef.damage;
    const range = wdef.range;
    const stat = (label, val, color) =>
      '<div class="wpn-stat"><span class="wpn-stat-label">' + label + '</span> <span style="color:' + color + '">' + val + '</span></div>';
    return '<div class="wpn-stats">' +
      stat('SKD', dmg, '#f77') +
      stat('SPS', sps, '#5af') +
      stat('RKV', range, '#5f5') +
      '</div>';
  }

  // ---- Weapons section ----
  const wpnSecEl = document.createElement('div');
  wpnSecEl.className = 'shop-section';
  wpnSecEl.innerHTML = '<h3>VÃ…PEN</h3>';

  Object.keys(weaponSections).forEach(secName => {
    const entry = weaponSections[secName];
    const unlock = entry.unlock;
    const isOwned = !unlock || (G.upgradeLevels[unlock.id] || 0) >= 1;
    const isExpanded = expandedWeaponSection === secName;

    const rowEl = document.createElement('div');
    rowEl.className = 'wpn-row';

    // Left: weapon name / unlock button
    const unlockEl = document.createElement('div');
    const stats = wpnStatsHtml(entry.weaponId);
    if (isOwned) {
      const dmgLvl = entry.dmg ? (G.upgradeLevels[entry.dmg.id] || 0) : 0;
      const rateLvl = entry.rate ? (G.upgradeLevels[entry.rate.id] || 0) : 0;
      const lvlStr = (dmgLvl > 0 || rateLvl > 0)
        ? '<div style="color:#0af;font-size:10px;margin-top:2px">Skade Lv.' + dmgLvl + ' | Ildrate Lv.' + rateLvl + '</div>'
        : '';
      unlockEl.className = 'wpn-unlock owned';
      unlockEl.innerHTML =
        '<span style="font-size:20px">' + (unlock ? unlock.icon : 'ðŸ”«') + '</span>' +
        '<div class="wpn-name">' + secName + lvlStr + stats + '</div>' +
        '<span class="wpn-owned-label">EID</span>';
    } else {
      const cost = upgradeCost(unlock, 0);
      const canAfford = G.coins >= cost;
      unlockEl.className = 'wpn-unlock' + (!canAfford ? ' cant-afford' : '');
      unlockEl.innerHTML =
        '<span style="font-size:20px">' + unlock.icon + '</span>' +
        '<div class="wpn-name">' + secName + stats + '</div>' +
        '<span class="wpn-price">' + cost + ' coins</span>';
      if (canAfford) {
        unlockEl.addEventListener('click', () => {
          G.coins -= cost;
          G.upgradeLevels[unlock.id] = 1;
          unlock.onBuy(G, 1);
          renderShop(secName);
          buildWeaponBar();
        });
      }
    }
    rowEl.appendChild(unlockEl);

    // Right: expand button (only if owned and has upgrades)
    if (isOwned && (entry.dmg || entry.rate)) {
      const expandBtn = document.createElement('div');
      expandBtn.className = 'wpn-expand-btn' + (isExpanded ? ' open' : '');
      expandBtn.textContent = isExpanded ? 'â–²' : 'â–¼';
      expandBtn.addEventListener('click', () => {
        renderShop(isExpanded ? null : secName);
      });
      rowEl.appendChild(expandBtn);
    }

    wpnSecEl.appendChild(rowEl);

    // Upgrade sub-panel (shown when expanded)
    if (isOwned && isExpanded && (entry.dmg || entry.rate)) {
      const upgPanel = document.createElement('div');
      upgPanel.className = 'wpn-upgrades';

      [entry.dmg, entry.rate].filter(Boolean).forEach(upg => {
        const lvl = G.upgradeLevels[upg.id] || 0;
        const cost = upgradeCost(upg, lvl);
        const canAfford = G.coins >= cost;
        const btn = document.createElement('div');
        btn.className = 'wpn-upg-btn' + (!canAfford ? ' cant-afford' : '');
        btn.innerHTML =
          '<div class="upg-icon">' + upg.icon + '</div>' +
          '<div class="upg-name">' + upg.name + (lvl > 0 ? ' <span style="color:#0af;font-size:10px">Lv.' + lvl + '</span>' : '') + '</div>' +
          '<div class="upg-desc">' + upg.desc(lvl) + '</div>' +
          '<div class="upg-price">' + cost + ' coins</div>';
        if (canAfford) {
          btn.addEventListener('click', () => {
            G.coins -= cost;
            const newLvl = lvl + 1;
            G.upgradeLevels[upg.id] = newLvl;
            upg.onBuy(G, newLvl);
            renderShop(secName);
          });
        }
        upgPanel.appendChild(btn);
      });

      wpnSecEl.appendChild(upgPanel);
    }
  });

  content.appendChild(wpnSecEl);

  // ---- Other sections (Rustning, Hunder, Drone osv) ----
  Object.keys(otherSections).forEach(section => {
    const secEl = document.createElement('div');
    secEl.className = 'shop-section';
    secEl.innerHTML = '<h3>' + section + '</h3>';
    const grid = document.createElement('div');
    grid.className = 'shop-items';

    otherSections[section].forEach(upg => {
      const level = G.upgradeLevels[upg.id] || 0;
      const maxReached = upg.maxLevel !== Infinity && level >= upg.maxLevel;
      const cost = upgradeCost(upg, level);
      const reqMet = !upg.requires || upg.requires === 'pistol_wpn' || (G.upgradeLevels[upg.requires] || 0) >= 1;
      const canAfford = G.coins >= cost;
      const levelBarPct = upg.maxLevel === Infinity ? 0 : (level / upg.maxLevel) * 100;

      const itemEl = document.createElement('div');
      itemEl.className = 'shop-item'
        + (maxReached ? ' owned' : '')
        + (!maxReached && (!canAfford || !reqMet) ? ' cant-afford' : '');

      let priceLabel;
      if (maxReached)      priceLabel = 'MAX';
      else if (!reqMet)    priceLabel = 'Krev: ' + upg.requires;
      else                 priceLabel = cost + ' coins';

      const levelTag = level > 0 ? ' <span style="color:#0af;font-size:10px">Lv.' + level + '</span>' : '';
      const barHtml = (upg.maxLevel !== Infinity && upg.maxLevel > 1)
        ? '<div class="level-bar"><div class="level-fill" style="width:' + levelBarPct + '%"></div></div>'
        : '';

      itemEl.innerHTML =
        '<h4>' + (upg.icon || '') + ' ' + upg.name + levelTag + '</h4>' +
        '<p>' + upg.desc(level) + '</p>' +
        '<div class="price">' + priceLabel + '</div>' +
        barHtml;

      if (!maxReached && canAfford && reqMet) {
        itemEl.addEventListener('click', (function(u, c) {
          return function() {
            G.coins -= c;
            const newLevel = (G.upgradeLevels[u.id] || 0) + 1;
            G.upgradeLevels[u.id] = newLevel;
            u.onBuy(G, newLevel);
            renderShop();
            buildWeaponBar();
          };
        })(upg, cost));
      }

      grid.appendChild(itemEl);
    });
    secEl.appendChild(grid);
    content.appendChild(secEl);
  });
}

// ========== WEAPON BAR ==========
function buildWeaponBar() {
  if (!G) return;
  const bar = document.getElementById('weapon-bar');
  bar.innerHTML = '';
  const available = WEAPON_DEFS.filter(w => G.unlockedWeapons.has(w.id));
  G.player.weapons = available.map(w => w.id);
  if (G.player.weaponIdx >= G.player.weapons.length) G.player.weaponIdx = 0;
  available.forEach((w, i) => {
    const slot = document.createElement('div');
    slot.className = 'weapon-slot' + (i === G.player.weaponIdx ? ' active' : '');
    slot.innerHTML = '<span style="font-size:20px">' + w.icon + '</span><span class="wname">' + (i+1) + '. ' + w.name + '</span>';
    slot.addEventListener('click', (function(idx) {
      return function() { G.player.weaponIdx = idx; buildWeaponBar(); };
    })(i));
    bar.appendChild(slot);
  });
}

// ========== INPUT ==========
document.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if (!G || G.gameOver) return;
  const num = parseInt(e.key);
  if (num >= 1 && num <= 9) {
    const idx = num - 1;
    if (idx < G.player.weapons.length) {
      G.player.weaponIdx = idx;
      buildWeaponBar();
    }
  }
  if (e.key.toLowerCase() === 'e') {
    if (G.shopOpen) closeShop();
    else openShop();
  }
  e.preventDefault();
});

document.addEventListener('keyup', e => {
  keys[e.key.toLowerCase()] = false;
});

// ========== TOUCH / JOYSTICK ==========
const JOY_RADIUS = 55;

function joyStart(x, y, id) {
  joystick.active = true;
  joystick.touchId = id;
  joystick.baseX = x;
  joystick.baseY = y;
  joystick.dx = 0;
  joystick.dy = 0;
}

function joyMove(x, y) {
  const raw_dx = x - joystick.baseX;
  const raw_dy = y - joystick.baseY;
  const len = Math.hypot(raw_dx, raw_dy);
  if (len > JOY_RADIUS) {
    joystick.dx = raw_dx / len;
    joystick.dy = raw_dy / len;
  } else {
    joystick.dx = raw_dx / JOY_RADIUS;
    joystick.dy = raw_dy / JOY_RADIUS;
  }
}

function joyEnd() {
  joystick.active = false;
  joystick.touchId = null;
  joystick.dx = 0;
  joystick.dy = 0;
}

canvas.addEventListener('touchstart', e => {
  if (G && G.gameOver) return; // let touches pass through to DOM buttons
  e.preventDefault();
  for (const t of e.changedTouches) {
    if (!joystick.active && t.clientX < canvas.width * 0.5) {
      joyStart(t.clientX, t.clientY, t.identifier);
    }
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  if (G && G.gameOver) return;
  e.preventDefault();
  for (const t of e.changedTouches) {
    if (t.identifier === joystick.touchId) {
      joyMove(t.clientX, t.clientY);
    }
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  if (G && G.gameOver) return;
  e.preventDefault();
  for (const t of e.changedTouches) {
    if (t.identifier === joystick.touchId) {
      joyEnd();
    }
  }
}, { passive: false });

canvas.addEventListener('touchcancel', e => {
  e.preventDefault();
  joyEnd();
}, { passive: false });

// ========== START ==========
initGame();
</script>
</body>
</html>
