<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dark Delta</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0a0a; color: #fff; font-family: 'Courier New', monospace; overflow: hidden; }
  canvas { display: block; }
  #ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
  #hud { position: fixed; top: 10px; left: 10px; font-size: 13px; color: #0f0; text-shadow: 0 0 6px #0f0; }
  #hud-right { position: fixed; top: 10px; right: 10px; text-align: right; font-size: 13px; color: #0f0; text-shadow: 0 0 6px #0f0; }
  #wave-banner { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); font-size: 36px; color: #ff0; text-shadow: 0 0 20px #ff0; display: none; pointer-events: none; }
  #shop-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.88); display: none; pointer-events: all; z-index: 100; }
  #shop-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); width: 720px; max-height: 90vh; overflow-y: auto; background: #0d0d1a; border: 2px solid #0af; border-radius: 8px; padding: 24px; }
  #shop-box h2 { color: #0af; text-align: center; margin-bottom: 6px; font-size: 22px; letter-spacing: 3px; }
  #shop-coins { text-align: center; color: #ff0; margin-bottom: 18px; font-size: 16px; }
  .shop-section { margin-bottom: 16px; }
  .shop-section h3 { color: #0f0; border-bottom: 1px solid #0f04; margin-bottom: 10px; padding-bottom: 4px; font-size: 13px; letter-spacing: 2px; }
  .shop-items { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
  .shop-item { background: #111; border: 1px solid #333; border-radius: 6px; padding: 10px; cursor: pointer; transition: border-color 0.2s; pointer-events: all; }
  .shop-item:hover { border-color: #0af; }
  .shop-item.owned { border-color: #0f0; opacity: 0.7; cursor: default; }
  .shop-item.cant-afford { opacity: 0.4; cursor: default; }
  .shop-item h4 { font-size: 12px; color: #fff; margin-bottom: 4px; }
  .shop-item p { font-size: 11px; color: #888; margin-bottom: 6px; }
  .shop-item .price { font-size: 12px; color: #ff0; }
  .shop-item .level-bar { height: 4px; background: #333; border-radius: 2px; margin-top: 6px; }
  .shop-item .level-fill { height: 100%; background: #0af; border-radius: 2px; transition: width 0.3s; }
  #close-shop { display: block; margin: 18px auto 0; padding: 10px 40px; background: #0af; color: #000; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-size: 14px; font-weight: bold; letter-spacing: 2px; }
  #close-shop:hover { background: #0df; }
  #game-over { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; z-index: 200; justify-content: center; align-items: center; flex-direction: column; }
  #game-over h1 { color: #f00; font-size: 48px; text-shadow: 0 0 30px #f00; margin-bottom: 20px; }
  #game-over p { color: #aaa; font-size: 18px; margin-bottom: 8px; }
  #restart-btn { margin-top: 24px; padding: 12px 40px; background: #f00; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-family: inherit; font-size: 16px; letter-spacing: 2px; }
  #restart-btn:hover { background: #f44; }
  #controls-hint { position: fixed; bottom: 10px; left: 10px; font-size: 11px; color: #444; }
  #weapon-bar { position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; }
  .weapon-slot { width: 54px; height: 54px; background: #111; border: 2px solid #333; border-radius: 6px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 10px; color: #888; cursor: pointer; pointer-events: all; transition: border-color 0.2s; }
  .weapon-slot.active { border-color: #ff0; color: #ff0; }
  .weapon-slot .wname { font-size: 9px; margin-top: 2px; }
  #shop-btn { position: fixed; bottom: 10px; right: 10px; padding: 8px 20px; background: #0af3; border: 1px solid #0af; color: #0af; border-radius: 4px; cursor: pointer; font-family: inherit; font-size: 12px; letter-spacing: 1px; pointer-events: all; }
  #shop-btn:hover { background: #0af5; }
  .companion-status { position: fixed; bottom: 110px; left: 10px; font-size: 11px; color: #0f0; text-shadow: 0 0 4px #0f0; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div id="hud">
    <div id="hud-hp">HP: <span id="hp-val">100</span></div>
    <div id="hud-coins">COINS: <span id="coins-val">0</span></div>
    <div id="hud-score">SCORE: <span id="score-val">0</span></div>
    <div id="hud-kills">KILLS: <span id="kills-val">0</span></div>
  </div>
  <div id="hud-right">
    <div>WAVE: <span id="wave-val">0</span></div>
    <div id="wave-status"></div>
  </div>
  <div id="wave-banner"></div>
  <div id="weapon-bar"></div>
  <div class="companion-status" id="companion-status"></div>
  <button id="shop-btn" onclick="openShop()">SHOP [E]</button>
  <div id="controls-hint">WASD: beveg | 1-5: bytt v&aring;pen | E: shop</div>
</div>

<div id="shop-overlay">
  <div id="shop-box">
    <h2>SUPPLY DROP</h2>
    <div id="shop-coins">COINS: <span id="shop-coins-val">0</span></div>
    <div id="shop-content"></div>
    <button id="close-shop" onclick="closeShop()">BACK TO BATTLE [E]</button>
  </div>
</div>

<div id="game-over" style="display:flex; display:none;">
  <h1>MISSION FAILED</h1>
  <p>Wave: <span id="go-wave">0</span></p>
  <p>Score: <span id="go-score">0</span></p>
  <p>Kills: <span id="go-kills">0</span></p>
  <button id="restart-btn" onclick="initGame()">RETRY</button>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

// ========== CONSTANTS ==========
const TILE = 48;
const COLORS = {
  ground: '#1a1a12',
  groundLight: '#1e1e16',
  player: '#4af',
  bullet: '#ff0',
  enemySoldier: '#c44',
  enemyHeavy: '#c84',
  enemyVehicle: '#996633',
  dog: '#c8822a',
  drone: '#4af',
  xp: '#ff0',
};

// ========== WEAPONS ==========
// Base stats â€” multiplied by weapon upgrade level in getCurrentWeapon()
const WEAPON_DEFS = [
  { id: 'pistol',   name: 'Pistol',  icon: 'ðŸ”«', damage: 18, rate: 400,  speed: 420, range: 320, spread: 0,    bullets: 1, explosive: false },
  { id: 'rifle',    name: 'Rifle',   icon: 'ðŸª–', damage: 28, rate: 180,  speed: 560, range: 480, spread: 0.05, bullets: 1, explosive: false },
  { id: 'shotgun',  name: 'Shotgun', icon: 'ðŸ’¥', damage: 22, rate: 700,  speed: 380, range: 260, spread: 0.25, bullets: 5, explosive: false },
  { id: 'smg',      name: 'SMG',     icon: 'âš¡', damage: 14, rate: 90,   speed: 500, range: 360, spread: 0.08, bullets: 1, explosive: false },
  { id: 'sniper',   name: 'Sniper',  icon: 'ðŸŽ¯', damage: 90, rate: 1200, speed: 800, range: 700, spread: 0,    bullets: 1, explosive: false },
  { id: 'launcher', name: 'RPG',     icon: 'ðŸš€', damage: 120,rate: 1800, speed: 300, range: 600, spread: 0,    bullets: 1, explosive: true  },
];

// ========== UPGRADE CATALOGUE ==========
// Each upgrade has infinite levels. Price and effect scale with current level.
// onBuy(g, level) is called with the NEW level (1, 2, 3, ...)
const UPGRADES = [
  // --- Unlock weapons (level 1 = unlock, no further levels) ---
  { id: 'buy_rifle',    section: 'VÃ¥pen',    name: 'Assault Rifle',  icon: 'ðŸª–',
    maxLevel: 1,
    baseCost: 80,
    desc: () => 'LÃ¥s opp Assault Rifle',
    onBuy: (g) => { g.unlockedWeapons.add('rifle'); } },
  { id: 'buy_shotgun',  section: 'VÃ¥pen',    name: 'Shotgun',        icon: 'ðŸ’¥',
    maxLevel: 1,
    baseCost: 100,
    desc: () => 'LÃ¥s opp Shotgun',
    onBuy: (g) => { g.unlockedWeapons.add('shotgun'); } },
  { id: 'buy_smg',      section: 'VÃ¥pen',    name: 'SMG',            icon: 'âš¡',
    maxLevel: 1,
    baseCost: 120,
    desc: () => 'LÃ¥s opp SMG',
    onBuy: (g) => { g.unlockedWeapons.add('smg'); } },
  { id: 'buy_sniper',   section: 'VÃ¥pen',    name: 'Sniper',         icon: 'ðŸŽ¯',
    maxLevel: 1,
    baseCost: 180,
    desc: () => 'LÃ¥s opp Sniper Rifle',
    onBuy: (g) => { g.unlockedWeapons.add('sniper'); } },
  { id: 'buy_launcher', section: 'VÃ¥pen',    name: 'RPG',            icon: 'ðŸš€',
    maxLevel: 1,
    baseCost: 300,
    desc: () => 'LÃ¥s opp RPG (eksplosiv)',
    onBuy: (g) => { g.unlockedWeapons.add('launcher'); } },

  // --- Weapon damage upgrades (infinite) ---
  { id: 'wpn_dmg',  section: 'VÃ¥pen',    name: 'Skade-oppgradering', icon: 'ðŸ”¥',
    maxLevel: Infinity,
    baseCost: 60,
    costScale: 1.4,
    desc: (lvl) => `+15% skade alle vÃ¥pen (NÃ¥vÃ¦rende: +${Math.round((Math.pow(1.15,lvl)-1)*100)}%)`,
    onBuy: (g, lvl) => { g.weaponDmgMult = (g.weaponDmgMult||1) * 1.15; } },
  { id: 'wpn_rate', section: 'VÃ¥pen',    name: 'Ildrate-oppgradering', icon: 'âš¡',
    maxLevel: Infinity,
    baseCost: 70,
    costScale: 1.4,
    desc: (lvl) => `+12% raskere skyting (NÃ¥vÃ¦rende: +${Math.round((Math.pow(1.12,lvl)-1)*100)}%)`,
    onBuy: (g, lvl) => { g.weaponRateMult = (g.weaponRateMult||1) * 0.88; } },

  // --- Armor (infinite) ---
  { id: 'armor',  section: 'Rustning',  name: 'Pansring',    icon: 'ðŸ›¡ï¸',
    maxLevel: Infinity,
    baseCost: 60,
    costScale: 1.35,
    desc: (lvl) => `+25 maks HP (Total bonus: +${lvl*25})`,
    onBuy: (g) => { g.player.maxHp += 25; g.player.hp += 25; } },
  { id: 'regen',  section: 'Rustning',  name: 'Regenerasjon', icon: 'ðŸ’‰',
    maxLevel: Infinity,
    baseCost: 80,
    costScale: 1.45,
    desc: (lvl) => `+0.8 HP/s (Total: ${(lvl*0.8).toFixed(1)} HP/s)`,
    onBuy: (g) => { g.player.regen += 0.8; } },
  { id: 'speed',  section: 'Rustning',  name: 'Hastighet',   icon: 'ðŸ‘Ÿ',
    maxLevel: Infinity,
    baseCost: 90,
    costScale: 1.5,
    desc: (lvl) => `+10% fart (Total: +${Math.round((Math.pow(1.1,lvl)-1)*100)}%)`,
    onBuy: (g) => { g.player.speed *= 1.10; } },

  // --- Dog ---
  { id: 'dog',      section: 'Rex (hund)', name: 'Rekrutter Rex', icon: 'ðŸ•',
    maxLevel: 1,
    baseCost: 150,
    desc: () => 'Rex jakter og biter fiender',
    onBuy: (g) => { g.dog = createDog(g); } },
  { id: 'dog_dmg',  section: 'Rex (hund)', name: 'Rex: Bittskade',   icon: 'ðŸ¦·',
    maxLevel: Infinity,
    baseCost: 80,
    costScale: 1.4,
    requires: 'dog',
    desc: (lvl) => `+30% bittskade (Total: +${Math.round((Math.pow(1.3,lvl)-1)*100)}%)`,
    onBuy: (g) => { if(g.dog) g.dog.damage *= 1.3; } },
  { id: 'dog_spd',  section: 'Rex (hund)', name: 'Rex: Hastighet',   icon: 'ðŸ¾',
    maxLevel: Infinity,
    baseCost: 70,
    costScale: 1.35,
    requires: 'dog',
    desc: (lvl) => `+20% hundehastighet`,
    onBuy: (g) => { if(g.dog) g.dog.speed *= 1.20; } },
  { id: 'dog_hp',   section: 'Rex (hund)', name: 'Rex: Pansring',    icon: 'ðŸ¦º',
    maxLevel: Infinity,
    baseCost: 70,
    costScale: 1.35,
    requires: 'dog',
    desc: (lvl) => `+60 Rex HP (Total bonus: +${lvl*60})`,
    onBuy: (g) => { if(g.dog){ g.dog.maxHp+=60; g.dog.hp+=60; } } },
  { id: 'dog_rate', section: 'Rex (hund)', name: 'Rex: Angrepsrate', icon: 'ðŸ’¢',
    maxLevel: Infinity,
    baseCost: 75,
    costScale: 1.4,
    requires: 'dog',
    desc: (lvl) => `+20% raskere angrep`,
    onBuy: (g) => { if(g.dog) g.dog.attackRate *= 0.80; } },

  // --- Drone ---
  { id: 'drone',      section: 'Drone',    name: 'Rekrutter Drone',  icon: 'ðŸš',
    maxLevel: 1,
    baseCost: 200,
    desc: () => 'Drone sirkulerer og skyter automatisk',
    onBuy: (g) => { g.drone = createDrone(g, 0); g.drones = [g.drone]; } },
  { id: 'drone_dmg',  section: 'Drone',    name: 'Drone: Skade',     icon: 'ðŸ’£',
    maxLevel: Infinity,
    baseCost: 90,
    costScale: 1.4,
    requires: 'drone',
    desc: (lvl) => `+35% droneskade (Total: +${Math.round((Math.pow(1.35,lvl)-1)*100)}%)`,
    onBuy: (g) => { (g.drones||[g.drone].filter(Boolean)).forEach(d => { if(d) d.damage *= 1.35; }); } },
  { id: 'drone_rate', section: 'Drone',    name: 'Drone: Ildrate',   icon: 'ðŸ”',
    maxLevel: Infinity,
    baseCost: 85,
    costScale: 1.4,
    requires: 'drone',
    desc: (lvl) => `+25% raskere droneskyting`,
    onBuy: (g) => { (g.drones||[g.drone].filter(Boolean)).forEach(d => { if(d) d.fireRate *= 0.75; }); } },
  { id: 'drone_hp',   section: 'Drone',    name: 'Drone: Pansring',  icon: 'ðŸ”©',
    maxLevel: Infinity,
    baseCost: 75,
    costScale: 1.35,
    requires: 'drone',
    desc: (lvl) => `+50 drone HP (Total bonus: +${lvl*50})`,
    onBuy: (g) => { (g.drones||[g.drone].filter(Boolean)).forEach(d => { if(d){ d.maxHp+=50; d.hp+=50; } }); } },
  { id: 'drone_count',section: 'Drone',    name: 'Drone: Ekstra',    icon: 'âž•',
    maxLevel: 3,
    baseCost: 250,
    costScale: 2.0,
    requires: 'drone',
    desc: (lvl) => `Legg til drone nr. ${lvl+1} (maks 4)`,
    onBuy: (g) => { g.extraDrones = (g.extraDrones||0)+1; rebuildDrones(g); } },
];

function upgradeCost(upg, currentLevel) {
  const base = upg.baseCost || 60;
  const scale = upg.costScale || 1.0;
  return Math.round(base * Math.pow(scale, currentLevel));
}

// ========== STATE ==========
let G; // global game state
let keys = {};
let animFrame;

// ========== HELPERS ==========
function rnd(a, b) { return a + Math.random() * (b - a); }
function rndInt(a, b) { return Math.floor(rnd(a, b + 1)); }
function dist(a, b) { return Math.hypot(b.x - a.x, b.y - a.y); }
function angle(a, b) { return Math.atan2(b.y - a.y, b.x - a.x); }
function norm(v) { const l = Math.hypot(v.x, v.y) || 1; return { x: v.x / l, y: v.y / l }; }

function spawnParticles(state, x, y, color, n, speedMin, speedMax, lifeMin, lifeMax, sizeMin=2, sizeMax=4) {
  for (let i = 0; i < n; i++) {
    const a = Math.random() * Math.PI * 2;
    const s = rnd(speedMin, speedMax);
    state.particles.push({
      x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s,
      life: rnd(lifeMin, lifeMax), maxLife: 1,
      color, size: rnd(sizeMin, sizeMax)
    });
  }
}

// ========== INIT ==========
function initGame() {
  cancelAnimationFrame(animFrame);
  document.getElementById('game-over').style.display = 'none';
  document.getElementById('shop-overlay').style.display = 'none';

  G = {
    time: 0,
    score: 0,
    coins: 0,
    kills: 0,
    wave: 0,
    waveState: 'prep', // 'prep', 'active', 'complete'
    waveTimer: 3000,
    waveEnemiesLeft: 0,
    waveSpawnTimer: 0,
    waveSpawnQueue: [],
    shopOpen: false,
    gameOver: false,
    paused: false,
    player: createPlayer(),
    bullets: [],
    enemyBullets: [],
    enemies: [],
    particles: [],
    floatTexts: [],
    drops: [],
    dog: null,
    drone: null,
    drones: [],
    extraDrones: 0,
    unlockedWeapons: new Set(['pistol']),
    purchasedUpgrades: new Set(),
    upgradeLevels: {},
    camX: 0,
    camY: 0,
    mapW: 3200,
    mapH: 2400,
  };

  G.player.x = G.mapW / 2;
  G.player.y = G.mapH / 2;

  buildWeaponBar();
  startNextWave();
  loop();
}

function createPlayer() {
  return {
    x: 0, y: 0, r: 14,
    hp: 100, maxHp: 100,
    speed: 160,
    regen: 0,
    facing: 0,
    fireTimer: 0,
    weapons: ['pistol'],
    weaponIdx: 0,
    invincibleTimer: 0,
    regenAccum: 0,
  };
}

function createDog(g) {
  return {
    x: g.player.x - 30, y: g.player.y,
    r: 10, hp: 120, maxHp: 120,
    speed: 220, damage: 25,
    attackCooldown: 0, attackRate: 800,
    target: null, state: 'follow',
    color: COLORS.dog,
  };
}

function createDrone(g, orbitOffset) {
  return {
    x: g.player.x, y: g.player.y - 40,
    r: 9, hp: 80, maxHp: 80,
    orbitAngle: orbitOffset || 0, orbitRadius: 55,
    damage: 20, fireRate: 600,
    fireTimer: 0, color: COLORS.drone,
  };
}

function rebuildDrones(g) {
  // Called after buying extra drones. Keeps the first drone's stats, adds new ones.
  const total = 1 + (g.extraDrones || 0);
  // Ensure g.drones array is in sync
  if (!g.drones) g.drones = g.drone ? [g.drone] : [];
  while (g.drones.length < total) {
    const offset = (g.drones.length / total) * Math.PI * 2;
    const nd = createDrone(g, offset);
    // Copy stats from first drone if it exists
    if (g.drones.length > 0) {
      nd.damage = g.drones[0].damage;
      nd.fireRate = g.drones[0].fireRate;
      nd.maxHp = g.drones[0].maxHp;
      nd.hp = g.drones[0].maxHp;
    }
    g.drones.push(nd);
  }
}

// ========== WAVES ==========
function startNextWave() {
  G.wave++;
  G.waveState = 'prep';
  G.waveTimer = 3000;
  document.getElementById('wave-val').textContent = G.wave;
  showWaveBanner('WAVE ' + G.wave);
}

function showWaveBanner(txt) {
  const el = document.getElementById('wave-banner');
  el.textContent = txt;
  el.style.display = 'block';
  setTimeout(() => { el.style.display = 'none'; }, 2000);
}

function buildWaveQueue() {
  const n = G.wave;
  const queue = [];
  // Exponential enemy count and HP scaling
  const soldierCount = Math.floor(5 + n * 2.5 + n * n * 0.3);
  const heavyCount   = Math.floor(n * 0.8 + n * n * 0.08);
  const vehicleCount = Math.floor(n * 0.5 + n * n * 0.04);
  for (let i = 0; i < soldierCount; i++) queue.push({ type: 'soldier', delay: i * 350 });
  for (let i = 0; i < heavyCount;   i++) queue.push({ type: 'heavy',   delay: 600 + i * 500 });
  for (let i = 0; i < vehicleCount; i++) queue.push({ type: 'vehicle', delay: 1000 + i * 800 });
  queue.sort((a, b) => a.delay - b.delay);
  G.waveSpawnQueue = queue;
  G.waveEnemiesLeft = queue.length;
  G.waveSpawnTimer = 0;
}

function spawnEnemy(type) {
  const p = G.player;
  // spawn off-screen (relative to camera)
  const side = rndInt(0, 3);
  const margin = 60;
  let x, y;
  const vw = canvas.width, vh = canvas.height;
  if (side === 0) { x = p.x + rnd(-vw * 0.7, vw * 0.7); y = p.y - vh * 0.6 - margin; }
  else if (side === 1) { x = p.x + rnd(-vw * 0.7, vw * 0.7); y = p.y + vh * 0.6 + margin; }
  else if (side === 2) { x = p.x - vw * 0.6 - margin; y = p.y + rnd(-vh * 0.7, vh * 0.7); }
  else { x = p.x + vw * 0.6 + margin; y = p.y + rnd(-vh * 0.7, vh * 0.7); }
  x = Math.max(20, Math.min(G.mapW - 20, x));
  y = Math.max(20, Math.min(G.mapH - 20, y));

  // Exponential HP/speed scaling
  const hpScale  = Math.pow(1.12, G.wave - 1);
  const spdScale = 1 + (G.wave - 1) * 0.05;
  if (type === 'soldier') {
    G.enemies.push({ type:'soldier', x, y, r:11, hp: 40*hpScale, maxHp:40*hpScale, speed:(80+G.wave*2)*spdScale, damage:10+G.wave*0.5, fireRate:1400, fireTimer:rnd(0,1400), range:280, color:COLORS.enemySoldier, score:10, coins:rndInt(2,5) });
  } else if (type === 'heavy') {
    G.enemies.push({ type:'heavy', x, y, r:16, hp: 140*hpScale, maxHp:140*hpScale, speed:(55+G.wave*1.5)*spdScale, damage:18+G.wave*0.8, fireRate:900, fireTimer:rnd(0,900), range:240, color:COLORS.enemyHeavy, score:30, coins:rndInt(8,14) });
  } else if (type === 'vehicle') {
    G.enemies.push({ type:'vehicle', x, y, r:22, hp: 300*hpScale, maxHp:300*hpScale, speed:(100+G.wave*3)*spdScale, damage:25+G.wave*1.2, fireRate:1800, fireTimer:rnd(0,1800), range:350, color:COLORS.enemyVehicle, score:80, coins:rndInt(20,35) });
  }
}

// ========== MAIN LOOP ==========
let lastTime = 0;
function loop(ts = 0) {
  if (G.gameOver) return;
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;
  if (!G.shopOpen && !G.paused) {
    update(dt * 1000);
  }
  render();
  animFrame = requestAnimationFrame(loop);
}

// ========== UPDATE ==========
function update(dt) {
  G.time += dt;
  const dtSec = dt / 1000;
  const p = G.player;

  // Camera
  G.camX = p.x - canvas.width / 2;
  G.camY = p.y - canvas.height / 2;

  // Player movement
  let dx = 0, dy = 0;
  if (keys['w'] || keys['arrowup'])    dy -= 1;
  if (keys['s'] || keys['arrowdown'])  dy += 1;
  if (keys['a'] || keys['arrowleft'])  dx -= 1;
  if (keys['d'] || keys['arrowright']) dx += 1;
  if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }
  p.x = Math.max(p.r, Math.min(G.mapW - p.r, p.x + dx * p.speed * dtSec));
  p.y = Math.max(p.r, Math.min(G.mapH - p.r, p.y + dy * p.speed * dtSec));

  // Player regen
  if (p.regen > 0) {
    p.regenAccum += p.regen * dtSec;
    if (p.regenAccum >= 1) { p.hp = Math.min(p.maxHp, p.hp + Math.floor(p.regenAccum)); p.regenAccum %= 1; }
  }

  // Invincibility frames
  if (p.invincibleTimer > 0) p.invincibleTimer -= dt;

  // Wave management
  if (G.waveState === 'prep') {
    G.waveTimer -= dt;
    if (G.waveTimer <= 0) {
      G.waveState = 'active';
      buildWaveQueue();
    }
  } else if (G.waveState === 'active') {
    // spawn from queue
    G.waveSpawnTimer += dt;
    while (G.waveSpawnQueue.length > 0 && G.waveSpawnTimer >= G.waveSpawnQueue[0].delay) {
      spawnEnemy(G.waveSpawnQueue.shift().type);
    }
    if (G.waveSpawnQueue.length === 0 && G.enemies.length === 0) {
      G.waveState = 'complete';
      G.waveTimer = 3000;
      document.getElementById('wave-status').textContent = 'WAVE CLEAR!';
    }
  } else if (G.waveState === 'complete') {
    G.waveTimer -= dt;
    if (G.waveTimer <= 0) {
      document.getElementById('wave-status').textContent = '';
      startNextWave();
    }
  }

  // Player auto-fire
  const wdef = getCurrentWeapon();
  p.fireTimer -= dt;
  if (p.fireTimer <= 0 && G.enemies.length > 0) {
    const target = nearestEnemy(p);
    if (target && dist(p, target) <= wdef.range) {
      fireWeapon(p, target, wdef);
      p.fireTimer = wdef.rate;
      p.facing = angle(p, target);
    }
  }

  // Move bullets
  G.bullets = G.bullets.filter(b => {
    b.x += b.vx * dtSec;
    b.y += b.vy * dtSec;
    b.life -= dt;
    if (b.life <= 0) return false;
    // hit enemies
    for (let i = G.enemies.length - 1; i >= 0; i--) {
      const e = G.enemies[i];
      if (dist(b, e) < e.r + b.r) {
        let dmg = b.damage;
        if (b.explosive) {
          // splash
          G.enemies.forEach(ee => { if (dist(b, ee) < 80) hitEnemy(ee, dmg * (1 - dist(b, ee) / 80)); });
          spawnParticles(G, b.x, b.y, '#f80', 18, 60, 200, 300, 600, 3, 8);
          return false;
        }
        hitEnemy(e, dmg);
        spawnParticles(G, b.x, b.y, '#f80', 5, 30, 100, 150, 350);
        return b.pierce ? true : false;
      }
    }
    return true;
  });

  // Enemy bullets
  G.enemyBullets = G.enemyBullets.filter(b => {
    b.x += b.vx * dtSec;
    b.y += b.vy * dtSec;
    b.life -= dt;
    if (b.life <= 0) return false;
    if (p.invincibleTimer <= 0 && dist(b, p) < p.r + b.r) {
      takeDamage(b.damage);
      spawnParticles(G, b.x, b.y, '#f00', 5, 30, 100, 150, 300);
      return false;
    }
    return true;
  });

  // Enemies
  for (let i = G.enemies.length - 1; i >= 0; i--) {
    const e = G.enemies[i];
    if (e.hp <= 0) {
      killEnemy(e, i);
      continue;
    }
    // Move toward player
    const a = angle(e, p);
    const avoidDist = e.r + 8;
    let ax = Math.cos(a), ay = Math.sin(a);
    // simple separation
    G.enemies.forEach((o, j) => {
      if (j === i) return;
      const d = dist(e, o);
      if (d < e.r + o.r + 4) {
        ax -= (o.x - e.x) / d * 0.6;
        ay -= (o.y - e.y) / d * 0.6;
      }
    });
    const mv = norm({x: ax, y: ay});
    const stopDist = e.type === 'vehicle' ? 180 : 140;
    if (dist(e, p) > stopDist) {
      e.x += mv.x * e.speed * dtSec;
      e.y += mv.y * e.speed * dtSec;
    }
    e.x = Math.max(e.r, Math.min(G.mapW - e.r, e.x));
    e.y = Math.max(e.r, Math.min(G.mapH - e.r, e.y));
    // Enemy fire
    e.fireTimer -= dt;
    if (e.fireTimer <= 0 && dist(e, p) <= e.range) {
      const ang = angle(e, p);
      const sp = 260 + Math.random() * 60;
      G.enemyBullets.push({ x: e.x, y: e.y, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp, damage: e.damage, r: 4, life: (e.range / sp) * 1000 + 200, color: '#f44' });
      e.fireTimer = e.fireRate;
    }
    // Ram damage
    if (p.invincibleTimer <= 0 && dist(e, p) < e.r + p.r + 2) {
      takeDamage(e.damage * 0.5);
      p.invincibleTimer = 500;
    }
  }

  // Dog
  if (G.dog) {
    updateDog(G.dog, dtSec);
  }

  // Drones
  if (G.drones && G.drones.length > 0) {
    const total = G.drones.length;
    G.drones = G.drones.filter(drone => {
      updateDrone(drone, dtSec, total);
      return drone.hp > 0;
    });
    // Keep G.drone in sync (first drone)
    G.drone = G.drones[0] || null;
  } else if (G.drone) {
    updateDrone(G.drone, dtSec, 1);
    if (G.drone.hp <= 0) G.drone = null;
  }

  // Particles
  G.particles = G.particles.filter(p => {
    p.x += p.vx * dtSec;
    p.y += p.vy * dtSec;
    p.vx *= 0.94;
    p.vy *= 0.94;
    p.life -= dt;
    return p.life > 0;
  });

  // Float texts
  G.floatTexts = G.floatTexts.filter(t => {
    t.y -= 28 * dtSec;
    t.life -= dt;
    return t.life > 0;
  });

  // Update HUD
  document.getElementById('hp-val').textContent = Math.ceil(p.hp) + '/' + p.maxHp;
  document.getElementById('coins-val').textContent = G.coins;
  document.getElementById('score-val').textContent = G.score;
  document.getElementById('kills-val').textContent = G.kills;

  // Update companion status
  let cs = '';
  if (G.dog) cs += 'Rex HP: ' + Math.ceil(G.dog.hp) + '/' + G.dog.maxHp + '  ';
  if (G.drones && G.drones.length > 0) {
    G.drones.forEach((d, i) => { cs += `Drone${G.drones.length>1?i+1:''} HP: ${Math.ceil(d.hp)}/${d.maxHp}  `; });
  } else if (G.drone) {
    cs += 'Drone HP: ' + Math.ceil(G.drone.hp) + '/' + G.drone.maxHp;
  }
  document.getElementById('companion-status').textContent = cs;
}

function getCurrentWeapon() {
  const p = G.player;
  const wname = p.weapons[p.weaponIdx] || 'pistol';
  const base = WEAPON_DEFS.find(w => w.id === wname) || WEAPON_DEFS[0];
  const dmgMult = G.weaponDmgMult || 1;
  const rateMult = G.weaponRateMult || 1;
  return Object.assign({}, base, {
    damage: base.damage * dmgMult,
    rate: base.rate * rateMult,
  });
}

function nearestEnemy(from) {
  let best = null, bestD = Infinity;
  G.enemies.forEach(e => {
    const d = dist(from, e);
    if (d < bestD) { bestD = d; best = e; }
  });
  return best;
}

function fireWeapon(shooter, target, wdef) {
  const baseAngle = angle(shooter, target);
  for (let i = 0; i < wdef.bullets; i++) {
    const a = baseAngle + (Math.random() - 0.5) * wdef.spread * 2;
    const lifeMs = (wdef.range / wdef.speed) * 1000 + 100;
    G.bullets.push({
      x: shooter.x, y: shooter.y,
      vx: Math.cos(a) * wdef.speed, vy: Math.sin(a) * wdef.speed,
      damage: wdef.damage, r: wdef.explosive ? 7 : 4,
      life: lifeMs, explosive: wdef.explosive || false,
      color: wdef.explosive ? '#f80' : COLORS.bullet,
      pierce: false,
    });
  }
}

function hitEnemy(e, dmg) {
  e.hp -= dmg;
  G.floatTexts.push({ x: e.x, y: e.y - e.r, text: '-' + Math.ceil(dmg), life: 600, color: '#ff0', size: 12 });
}

function killEnemy(e, idx) {
  G.enemies.splice(idx, 1);
  G.kills++;
  G.score += e.score;
  G.coins += e.coins;
  spawnParticles(G, e.x, e.y, e.color, 12, 40, 160, 300, 700, 3, 6);
  G.floatTexts.push({ x: e.x, y: e.y - 20, text: '+' + e.coins, life: 900, color: '#ff0', size: 13 });
}

function takeDamage(dmg) {
  G.player.hp -= dmg;
  spawnParticles(G, G.player.x, G.player.y, '#f00', 8, 30, 120, 200, 500);
  if (G.player.hp <= 0) {
    G.gameOver = true;
    document.getElementById('go-wave').textContent = G.wave;
    document.getElementById('go-score').textContent = G.score;
    document.getElementById('go-kills').textContent = G.kills;
    document.getElementById('game-over').style.display = 'flex';
  }
}

function updateDog(dog, dtSec) {
  if (dog.hp <= 0) { G.dog = null; return; }
  // Find target
  if (!dog.target || dog.target.hp <= 0 || dist(dog, dog.target) > 300) {
    dog.target = nearestEnemy(dog);
  }
  if (dog.target) {
    // Chase target
    const a = angle(dog, dog.target);
    dog.x += Math.cos(a) * dog.speed * dtSec;
    dog.y += Math.sin(a) * dog.speed * dtSec;
    // Attack
    dog.attackCooldown -= dtSec * 1000;
    if (dog.attackCooldown <= 0 && dist(dog, dog.target) < dog.r + dog.target.r + 8) {
      hitEnemy(dog.target, dog.damage);
      dog.attackCooldown = dog.attackRate;
      spawnParticles(G, dog.x, dog.y, '#c82', 5, 20, 80, 150, 300);
    }
  } else {
    // Follow player
    const a = angle(dog, G.player);
    const d = dist(dog, G.player);
    if (d > 50) {
      dog.x += Math.cos(a) * dog.speed * dtSec;
      dog.y += Math.sin(a) * dog.speed * dtSec;
    }
  }
}

function updateDrone(drone, dtSec, total) {
  if (drone.hp <= 0) return;
  // Orbit around player, evenly spaced if multiple drones
  drone.orbitAngle += dtSec * 1.5;
  drone.x = G.player.x + Math.cos(drone.orbitAngle) * drone.orbitRadius;
  drone.y = G.player.y + Math.sin(drone.orbitAngle) * drone.orbitRadius;
  // Fire at nearest enemy
  drone.fireTimer -= dtSec * 1000;
  if (drone.fireTimer <= 0 && G.enemies.length > 0) {
    const target = nearestEnemy(drone);
    if (target && dist(drone, target) < 400) {
      fireWeapon(drone, target, { damage: drone.damage, speed: 480, range: 400, spread: 0.04, bullets: 1, explosive: false });
      drone.fireTimer = drone.fireRate;
    }
  }
}

// ========== RENDER ==========
function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(-G.camX, -G.camY);

  // Ground tiles
  const tileW = 80, tileH = 80;
  const startX = Math.floor(G.camX / tileW) * tileW;
  const startY = Math.floor(G.camY / tileH) * tileH;
  for (let tx = startX; tx < G.camX + canvas.width + tileW; tx += tileW) {
    for (let ty = startY; ty < G.camY + canvas.height + tileH; ty += tileH) {
      const ix = Math.floor(tx / tileW);
      const iy = Math.floor(ty / tileH);
      ctx.fillStyle = (ix + iy) % 2 === 0 ? '#141410' : '#111109';
      ctx.fillRect(tx, ty, tileW, tileH);
    }
  }
  // Map border
  ctx.strokeStyle = '#f004';
  ctx.lineWidth = 3;
  ctx.strokeRect(0, 0, G.mapW, G.mapH);

  // Particles
  G.particles.forEach(p => {
    const alpha = p.life / 600;
    ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;

  // Dog
  if (G.dog) drawDog(G.dog);

  // Drones
  if (G.drones && G.drones.length > 0) {
    G.drones.forEach(d => drawDrone(d));
  } else if (G.drone) {
    drawDrone(G.drone);
  }

  // Enemies
  G.enemies.forEach(e => drawEnemy(e));

  // Player
  drawPlayer(G.player);

  // Bullets
  G.bullets.forEach(b => {
    ctx.shadowBlur = 8;
    ctx.shadowColor = b.color;
    ctx.fillStyle = b.color;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.shadowBlur = 0;

  // Enemy bullets
  G.enemyBullets.forEach(b => {
    ctx.fillStyle = b.color;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fill();
  });

  // Float texts
  G.floatTexts.forEach(t => {
    ctx.globalAlpha = Math.min(1, t.life / 300);
    ctx.fillStyle = t.color;
    ctx.font = `bold ${t.size || 13}px Courier New`;
    ctx.textAlign = 'center';
    ctx.fillText(t.text, t.x, t.y);
  });
  ctx.globalAlpha = 1;
  ctx.textAlign = 'left';

  ctx.restore();

  // HUD: health bar
  const barW = 180, barH = 10;
  const bx = 10, by = 90;
  ctx.fillStyle = '#222';
  ctx.fillRect(bx, by, barW, barH);
  const hpFrac = Math.max(0, G.player.hp / G.player.maxHp);
  const hpColor = hpFrac > 0.5 ? '#0f0' : hpFrac > 0.25 ? '#ff0' : '#f00';
  ctx.fillStyle = hpColor;
  ctx.fillRect(bx, by, barW * hpFrac, barH);
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  ctx.strokeRect(bx, by, barW, barH);
}

function drawSoldierTopDown(s, helmetColor, vestColor, vestAccent, skinColor, eyeColor) {
  // TOP-DOWN perspective. +X = forward (facing direction).
  // Think of looking straight down at a person lying flat:
  //   - Shoulders are the WIDEST part (large Y extent)
  //   - Body depth front-to-back is NARROW (small X extent)
  //   - Head/helmet sits at the FRONT (+X), appears as a large circle
  //   - Feet stick out at the BACK (-X)

  const f = s; // scale factor

  // SHADOW
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.beginPath();
  ctx.ellipse(0, 0, 14*f, 10*f, 0, 0, Math.PI*2);
  ctx.fill();

  // FEET â€” two small ovals at the back (-X), spread apart (Â±Y)
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.ellipse(-10*f, -3.5*f, 3.5*f, 2*f, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(-10*f,  3.5*f, 3.5*f, 2*f, 0, 0, Math.PI*2);
  ctx.fill();

  // LOWER LEGS â€” slightly in front of feet, same spread
  ctx.fillStyle = '#222a20';
  ctx.beginPath();
  ctx.ellipse(-6*f, -3.5*f, 3.5*f, 2*f, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(-6*f,  3.5*f, 3.5*f, 2*f, 0, 0, Math.PI*2);
  ctx.fill();

  // TORSO + SHOULDERS â€” the key shape:
  // A wide short oval: narrow front-to-back (X ~6), very wide side-to-side (Y ~11)
  // This makes the shoulders clearly visible sticking out left and right
  ctx.fillStyle = vestColor;
  ctx.beginPath();
  ctx.ellipse(0, 0, 6*f, 11*f, 0, 0, Math.PI*2);
  ctx.fill();

  // VEST front plate â€” a smaller oval in the center of the torso
  ctx.fillStyle = vestAccent;
  ctx.beginPath();
  ctx.ellipse(1*f, 0, 4*f, 6*f, 0, 0, Math.PI*2);
  ctx.fill();

  // Vest strap lines across chest
  ctx.strokeStyle = 'rgba(0,0,0,0.4)';
  ctx.lineWidth = 1.2*f;
  ctx.beginPath();
  ctx.moveTo(-3*f, -5*f); ctx.lineTo(3*f, -5*f);
  ctx.moveTo(-3*f,  5*f); ctx.lineTo(3*f,  5*f);
  ctx.stroke();

  // ARMS â€” two ovals angled forward from shoulders, reaching toward the gun
  ctx.fillStyle = vestColor;
  ctx.beginPath();
  ctx.ellipse(5*f, -8*f, 5.5*f, 2.5*f, -0.3, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(5*f,  8*f, 5.5*f, 2.5*f,  0.3, 0, Math.PI*2);
  ctx.fill();

  // HANDS gripping gun
  ctx.fillStyle = skinColor;
  ctx.beginPath();
  ctx.ellipse(8*f, -5*f, 2.5*f, 2*f, -0.3, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(8*f,  5*f, 2.5*f, 2*f,  0.3, 0, Math.PI*2);
  ctx.fill();

  // GUN â€” a thin long rectangle pointing forward along +X
  ctx.fillStyle = '#2a2a2a';
  ctx.beginPath();
  ctx.roundRect(6*f, -1.2*f, 17*f, 2.4*f, 1);
  ctx.fill();
  // Barrel (thinner, at the front)
  ctx.fillStyle = '#444';
  ctx.beginPath();
  ctx.roundRect(14*f, -0.8*f, 9*f, 1.6*f, 1);
  ctx.fill();
  // Muzzle flash hint
  ctx.fillStyle = '#666';
  ctx.beginPath();
  ctx.arc(23*f, 0, 1.2*f, 0, Math.PI*2);
  ctx.fill();

  // NECK â€” small connection between torso and helmet
  ctx.fillStyle = skinColor;
  ctx.beginPath();
  ctx.ellipse(7*f, 0, 2.5*f, 2*f, 0, 0, Math.PI*2);
  ctx.fill();

  // HELMET â€” large circle at front (+X), the dominant visual element
  // Drawn last so it sits "on top"
  ctx.fillStyle = helmetColor;
  ctx.beginPath();
  ctx.arc(9*f, 0, 7*f, 0, Math.PI*2);
  ctx.fill();

  // Helmet dome shading â€” radial gradient to suggest 3D roundness
  const grad = ctx.createRadialGradient(7*f, -2*f, 0.5*f, 9*f, 0, 7*f);
  grad.addColorStop(0,   'rgba(255,255,255,0.18)');
  grad.addColorStop(0.5, 'rgba(0,0,0,0)');
  grad.addColorStop(1,   'rgba(0,0,0,0.45)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(9*f, 0, 7*f, 0, Math.PI*2);
  ctx.fill();

  // Helmet outline
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.lineWidth = 1.2*f;
  ctx.beginPath();
  ctx.arc(9*f, 0, 7*f, 0, Math.PI*2);
  ctx.stroke();

  // Helmet center ridge
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 1.5*f;
  ctx.beginPath();
  ctx.moveTo(3*f, 0); ctx.lineTo(15*f, 0);
  ctx.stroke();

  // Face visible at very front of helmet (visor area)
  ctx.fillStyle = skinColor;
  ctx.beginPath();
  ctx.ellipse(14*f, 0, 2.5*f, 2*f, 0, 0, Math.PI*2);
  ctx.fill();

  // Eyes
  ctx.fillStyle = eyeColor;
  ctx.beginPath();
  ctx.ellipse(14*f, -1*f, 1*f, 0.8*f, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(14*f,  1*f, 1*f, 0.8*f, 0, 0, Math.PI*2);
  ctx.fill();
}

function drawPlayer(p) {
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(p.facing);

  drawSoldierTopDown(1.0, '#2e4a2a', '#2a3a28', '#3a5035', '#b08060', '#1a4a5a');

  // Blue team glow ring
  ctx.shadowBlur = 8;
  ctx.shadowColor = '#4af';
  ctx.strokeStyle = '#4af8';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(0, 0, p.r + 2, 0, Math.PI*2);
  ctx.stroke();
  ctx.shadowBlur = 0;

  ctx.restore();
}

function drawEnemy(e) {
  ctx.save();
  ctx.translate(e.x, e.y);

  if (e.type === 'vehicle') {
    // Vehicle: rectangle
    ctx.fillStyle = e.color;
    ctx.beginPath();
    ctx.roundRect(-e.r, -e.r * 0.6, e.r * 2, e.r * 1.2, 3);
    ctx.fill();
    ctx.strokeStyle = '#c84';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // Turret
    ctx.fillStyle = '#885522';
    ctx.beginPath();
    ctx.arc(0, 0, e.r * 0.5, 0, Math.PI * 2);
    ctx.fill();
    // barrel
    const a2 = angle(e, G.player);
    ctx.strokeStyle = '#664422';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(Math.cos(a2) * e.r * 1.1, Math.sin(a2) * e.r * 1.1);
    ctx.stroke();
  } else {
    // --- Enemy Soldier / Heavy â€” reuse shared top-down soldier draw ---
    const a2 = angle(e, G.player);
    ctx.rotate(a2);

    const s = e.type === 'heavy' ? 1.35 : 1.0;
    if (e.type === 'heavy') {
      drawSoldierTopDown(s, '#3a2008', '#5a3010', '#7a4820', '#b07050', '#ff3333');
    } else {
      drawSoldierTopDown(s, '#3a0808', '#6b2020', '#8b3030', '#b07050', '#ff3333');
    }
  }

  ctx.restore();

  // HP bar (drawn after restore so it's axis-aligned)
  ctx.save();
  ctx.translate(e.x, e.y);
  const bw = e.r * 2.4;
  ctx.fillStyle = '#400';
  ctx.fillRect(-bw / 2, -e.r - 10, bw, 5);
  ctx.fillStyle = '#f00';
  ctx.fillRect(-bw / 2, -e.r - 10, bw * Math.max(0, e.hp / e.maxHp), 5);
  ctx.strokeStyle = '#600';
  ctx.lineWidth = 0.5;
  ctx.strokeRect(-bw / 2, -e.r - 10, bw, 5);
  ctx.restore();
}

function drawDog(dog) {
  ctx.save();
  ctx.translate(dog.x, dog.y);

  // Forward = +X. Rotate so snout points toward target.
  const dogTarget = dog.target && dog.target.hp > 0 ? dog.target : G.player;
  ctx.rotate(angle(dog, dogTarget));

  // Animated tail wag (tail is at -X end)
  const waggle = Math.sin(G.time * 0.012) * 0.5;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(0, 0, 12, 7, 0, 0, Math.PI * 2);
  ctx.fill();

  // Tail (at rear, -X side)
  ctx.save();
  ctx.translate(-9, 0);
  ctx.rotate(waggle);
  ctx.fillStyle = '#b07030';
  ctx.beginPath();
  ctx.moveTo(0, -2);
  ctx.quadraticCurveTo(-6, -6, -10, -2);
  ctx.quadraticCurveTo(-12, 0, -10, 2);
  ctx.quadraticCurveTo(-6, 6, 0, 2);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#d09050';
  ctx.beginPath();
  ctx.ellipse(-10, 0, 2.5, 2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // Back legs (splayed outward at rear)
  ctx.fillStyle = '#a06828';
  ctx.beginPath();
  ctx.ellipse(-5, -6, 4, 2.5, 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(-5, 6, 4, 2.5, -0.3, 0, Math.PI * 2);
  ctx.fill();
  // Back paws
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.ellipse(-2, -6, 2.5, 1.8, 0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(-2, 6, 2.5, 1.8, -0.2, 0, Math.PI * 2);
  ctx.fill();

  // Body â€” elongated oval along X axis
  ctx.fillStyle = '#c8822a';
  ctx.beginPath();
  ctx.ellipse(0, 0, 9, 6, 0, 0, Math.PI * 2);
  ctx.fill();
  // Saddle patch (darker)
  ctx.fillStyle = '#a06020';
  ctx.beginPath();
  ctx.ellipse(-1, 0, 5, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  // Belly (lighter center stripe)
  ctx.fillStyle = '#e0a050';
  ctx.beginPath();
  ctx.ellipse(1, 0, 5, 2.5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Front legs (forward, splayed)
  ctx.fillStyle = '#c8822a';
  ctx.beginPath();
  ctx.ellipse(5, -6, 4, 2.5, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(5, 6, 4, 2.5, 0.3, 0, Math.PI * 2);
  ctx.fill();
  // Front paws
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.ellipse(2, -6, 2.5, 1.8, -0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(2, 6, 2.5, 1.8, 0.2, 0, Math.PI * 2);
  ctx.fill();

  // Neck
  ctx.fillStyle = '#c8822a';
  ctx.beginPath();
  ctx.ellipse(9, 0, 4, 4.5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Collar (tactical red, around neck)
  ctx.fillStyle = '#cc2222';
  ctx.beginPath();
  ctx.ellipse(8, 0, 3.5, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#c8822a'; // neck skin inside collar
  ctx.beginPath();
  ctx.ellipse(8, 0, 2.5, 4, 0, 0, Math.PI * 2);
  ctx.fill();
  // Tag
  ctx.fillStyle = '#ffaa00';
  ctx.beginPath();
  ctx.arc(7, 4, 1.5, 0, Math.PI * 2);
  ctx.fill();

  // Head â€” at +X tip
  ctx.fillStyle = '#d89040';
  ctx.beginPath();
  ctx.ellipse(13, 0, 6, 5.5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Ears (floppy, on top/bottom of head from above)
  ctx.fillStyle = '#a86020';
  ctx.beginPath();
  ctx.ellipse(12, -7, 3, 5, 0.2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(12, 7, 3, 5, -0.2, 0, Math.PI * 2);
  ctx.fill();

  // Snout
  ctx.fillStyle = '#b87030';
  ctx.beginPath();
  ctx.ellipse(17, 0, 4, 3, 0, 0, Math.PI * 2);
  ctx.fill();
  // Nose
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.ellipse(20, 0, 2, 1.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#555';
  ctx.beginPath();
  ctx.arc(20, 0, 0.7, 0, Math.PI * 2);
  ctx.fill();

  // Eyes (on sides of head, from above)
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(13, -4.5, 1.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(13, 4.5, 1.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(13.5, -5, 0.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(13.5, 4, 0.5, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();

  // HP bar (axis-aligned, drawn after restore)
  ctx.save();
  ctx.translate(dog.x, dog.y);
  const bw = 28;
  ctx.fillStyle = '#300';
  ctx.fillRect(-bw / 2, -20, bw, 4);
  ctx.fillStyle = '#0c0';
  ctx.fillRect(-bw / 2, -20, bw * Math.max(0, dog.hp / dog.maxHp), 4);
  ctx.strokeStyle = '#050';
  ctx.lineWidth = 0.5;
  ctx.strokeRect(-bw / 2, -20, bw, 4);
  ctx.restore();
}

function drawDrone(drone) {
  ctx.save();
  ctx.translate(drone.x, drone.y);
  ctx.rotate(G.time * 0.003);
  ctx.shadowBlur = 12;
  ctx.shadowColor = '#4af';
  // Body
  ctx.fillStyle = '#1a2a4a';
  ctx.beginPath();
  ctx.arc(0, 0, drone.r, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = '#4af';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  // Rotors (4 lines)
  for (let i = 0; i < 4; i++) {
    const a = (i / 4) * Math.PI * 2;
    ctx.strokeStyle = '#4af8';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(Math.cos(a) * drone.r * 0.8, Math.sin(a) * drone.r * 0.8);
    ctx.lineTo(Math.cos(a) * drone.r * 1.6, Math.sin(a) * drone.r * 1.6);
    ctx.stroke();
  }
  ctx.shadowBlur = 0;
  // HP bar
  const bw = 22;
  ctx.fillStyle = '#003';
  ctx.fillRect(-bw / 2, -drone.r - 8, bw, 4);
  ctx.fillStyle = '#0af';
  ctx.fillRect(-bw / 2, -drone.r - 8, bw * (drone.hp / drone.maxHp), 4);
  ctx.restore();
}

// ========== SHOP ==========
function openShop() {
  G.shopOpen = true;
  document.getElementById('shop-overlay').style.display = 'block';
  renderShop();
}

function closeShop() {
  G.shopOpen = false;
  document.getElementById('shop-overlay').style.display = 'none';
  buildWeaponBar();
}

function renderShop() {
  document.getElementById('shop-coins-val').textContent = G.coins;
  const content = document.getElementById('shop-content');
  content.innerHTML = '';

  // Group by section
  const sections = {};
  UPGRADES.forEach(upg => {
    if (!sections[upg.section]) sections[upg.section] = [];
    sections[upg.section].push(upg);
  });

  Object.keys(sections).forEach(section => {
    const secEl = document.createElement('div');
    secEl.className = 'shop-section';
    secEl.innerHTML = `<h3>${section}</h3>`;
    const grid = document.createElement('div');
    grid.className = 'shop-items';

    sections[section].forEach(upg => {
      const level = G.upgradeLevels[upg.id] || 0;
      const maxReached = upg.maxLevel !== Infinity && level >= upg.maxLevel;
      const cost = upgradeCost(upg, level);
      const reqMet = !upg.requires || (G.upgradeLevels[upg.requires] || 0) >= 1;
      const canAfford = G.coins >= cost;
      const levelBarPct = upg.maxLevel === Infinity ? 0 : (level / upg.maxLevel) * 100;

      const itemEl = document.createElement('div');
      itemEl.className = 'shop-item'
        + (maxReached ? ' owned' : '')
        + (!maxReached && (!canAfford || !reqMet) ? ' cant-afford' : '');

      let priceLabel;
      if (maxReached) {
        priceLabel = 'MAX';
      } else if (!reqMet) {
        priceLabel = 'Krev: ' + upg.requires;
      } else {
        priceLabel = cost + ' coins';
      }

      const levelTag = level > 0 ? ` <span style="color:#0af;font-size:10px">Lv.${level}</span>` : '';

      itemEl.innerHTML = `
        <h4>${upg.icon || ''} ${upg.name}${levelTag}</h4>
        <p>${upg.desc(level)}</p>
        <div class="price">${priceLabel}</div>
        ${upg.maxLevel !== Infinity && upg.maxLevel > 1
          ? `<div class="level-bar"><div class="level-fill" style="width:${levelBarPct}%"></div></div>`
          : ''}
      `;

      if (!maxReached && canAfford && reqMet) {
        itemEl.addEventListener('click', () => {
          G.coins -= cost;
          const newLevel = (G.upgradeLevels[upg.id] || 0) + 1;
          G.upgradeLevels[upg.id] = newLevel;
          upg.onBuy(G, newLevel);
          renderShop();
          buildWeaponBar();
        });
      }

      grid.appendChild(itemEl);
    });
    secEl.appendChild(grid);
    content.appendChild(secEl);
  });
}

// ========== WEAPON BAR ==========
function buildWeaponBar() {
  if (!G) return;
  const bar = document.getElementById('weapon-bar');
  bar.innerHTML = '';
  const available = WEAPON_DEFS.filter(w => G.unlockedWeapons.has(w.id));
  G.player.weapons = available.map(w => w.id);
  if (G.player.weaponIdx >= G.player.weapons.length) G.player.weaponIdx = 0;
  available.forEach((w, i) => {
    const slot = document.createElement('div');
    slot.className = 'weapon-slot' + (i === G.player.weaponIdx ? ' active' : '');
    slot.innerHTML = `<span style="font-size:20px">${w.icon}</span><span class="wname">${i+1}. ${w.name}</span>`;
    slot.addEventListener('click', () => { G.player.weaponIdx = i; buildWeaponBar(); });
    bar.appendChild(slot);
  });
}

// ========== INPUT ==========
document.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if (!G || G.gameOver) return;
  // Weapon switch
  const num = parseInt(e.key);
  if (num >= 1 && num <= 9) {
    const idx = num - 1;
    if (idx < G.player.weapons.length) {
      G.player.weaponIdx = idx;
      buildWeaponBar();
    }
  }
  // Shop
  if (e.key.toLowerCase() === 'e') {
    if (G.shopOpen) closeShop();
    else openShop();
  }
  e.preventDefault();
});

document.addEventListener('keyup', e => {
  keys[e.key.toLowerCase()] = false;
});

// ========== START ==========
initGame();
</script>
</body>
</html>
